<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/Python/PropertyNameSpace.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:15:42 GMT -->
<head>














  
  
  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">







  
  
  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">







  
  
  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>特性名稱空間</title></head><body>







<h3><a href="../index.html">From
Gossip@Openhome</a></h3>







<h1><a href="index-2.html">Python Gossip: 特性名稱空間<br>
</a></h1>

<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">

  <tbody>

    <tr>

      <td style="vertical-align: top; width: 250px; text-align: center;">
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>

      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br><br> <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br><br><center> </center></td>

      <td style="vertical-align: top; width: 690px; text-align: left;"><small>一個事實是：<span style="font-weight: bold;">類別（Class）或實例（Instance）本身的作用是作為特性（Property）的名稱空間（Namespace）</span>。類別或實例本身會擁有一個<span style="font-family: Courier New,Courier,monospace; font-weight: bold;">__dict__</span>特性參考至一個字典物件，其中記錄著類別或實例所擁有的特性。例如：</small><small><br></small>
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">





        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; class Math:<br>
...&nbsp;&nbsp;&nbsp;&nbsp; PI = 3.14159<br>
...<br>
&gt;&gt;&gt; Math.PI<br>
</span>3.14159<span style="font-weight: bold;"><br>
&gt;&gt;&gt; print(Math.__dict__)<br>
            </span>{'__dict__': &lt;attribute '__dict__' of 'Math' objects&gt;, '__module__': '__main__',<br>
&nbsp;'PI': 3.14159, '__weakref__': &lt;attribute '__weakref__' of 'Math' objects&gt;, '__d<br>
oc__': None}<span style="font-weight: bold;"><br>
&gt;&gt;&gt; Math.__dict__['PI']<br>
            </span>3.14159<span style="font-weight: bold;"><br>
&gt;&gt;&gt;</span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      </table>
      <br>
      <small style="font-family: Courier New,Courier,monospace;">在上例中，Math類別上定義了PI特性，這記錄在Math.__dict__中，你嘗試使用Math.PI，則使用Math.__dict__['PI']來尋找出對應的值。如果你試著透過實例來取得PI：</small><small><br></small>
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">






        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; m = Math()<br>
&gt;&gt;&gt; m.PI<br>
</span>3.14159<span style="font-weight: bold;"><br>
&gt;&gt;&gt; print(m.__dict__)<br>
            </span>{}<span style="font-weight: bold;"><br>
&gt;&gt;&gt;</span><span style="font-weight: bold;"></span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      </table>

      <br>
      <small style="font-family: Courier New,Courier,monospace;">實際上m所參考的實例，其__dict__中並沒有PI，此時會到Math.__dict__中找看看有無PI。這是</small><small>Python</small><small style="font-family: Courier New,Courier,monospace;">中尋找特性的順序：<span style="font-weight: bold;">如果實例的__dict__中沒有，則到產生實例的類別__dict__中尋找</span>。如果你試著在m實例上設定PI特性：</small><small><br></small>
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">







        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; m.PI<br>
</span>3.14<span style="font-weight: bold;"><br>
&gt;&gt;&gt; Math.PI<br>
            </span>3.14159<span style="font-weight: bold;"><br>
&gt;&gt;&gt; print(m.__dict__)<br>
            </span>{'PI': 3.14}<span style="font-weight: bold;"><br>
&gt;&gt;&gt; print(Math.__dict__)<br>
            </span>{'__dict__': &lt;attribute '__dict__' of 'Math' objects&gt;, '__module__': '__main__',<br>
&nbsp;'PI': 3.14159, '__weakref__': &lt;attribute '__weakref__' of 'Math' objects&gt;, '__d<br>
oc__': None}<br>
            <span style="font-weight: bold;">&gt;&gt;&gt;</span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      </table>


      <br>
      <small style="font-family: Courier New,Courier,monospace;">實際上你並沒有改變Math.__dict__中的PI，而是在實例m.__dict__中新增一個PI，而你嘗試使用實例存取PI時，由於m.__dict__中已經有了，就直接取得該值。</small><br>
      <br>
      <small>這也說明了，為什麼實例方法的第一個參數會綁定至實例：</small><small><br></small>
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">








        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; class Some:<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def setx(self, x):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.x = x<br>
...<br>
&gt;&gt;&gt; s = Some()<br>
&gt;&gt;&gt; print(Some.__dict__)<br>
</span>{'__dict__': &lt;attribute '__dict__' of 'Some' objects&gt;, '__weakref__': &lt;attribute<br>
&nbsp;'__weakref__' of 'Some' objects&gt;, '__module__': '__main__', 'setx': &lt;function s<br>
etx at 0x018FA078&gt;, '__doc__': None}<span style="font-weight: bold;"><br>
&gt;&gt;&gt; print(s.__dict__)<br>
            </span>{}<span style="font-weight: bold;"><br>
&gt;&gt;&gt; s.setx(10)<br>
&gt;&gt;&gt; print(s.__dict__)<br>
            </span>{'x': 10}<span style="font-weight: bold;"><br>
&gt;&gt;&gt;</span><span style="font-weight: bold;"></span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      </table>



      <br>
      <small>類別中所定義的函式，其實就是類別的特性，也就是在類別的<span style="font-family: Courier New,Courier,monospace;">__dict__</span>中可以找到該名稱。實例方法的第一個參數<span style="font-family: Courier New,Courier,monospace;">self綁定實例，透過self.x來設定特性值，也就是在self.__dict__中添增特性。<br>
      <br>
</span></small><small>由於Python可以動態地為類別添加屬性，即使是未</small><small>添加屬性前就已建立的物件，在類別動態添加屬性之後，
也可依Python的名稱空間搜尋順序套用上新的屬性，用這種方式，您可以為類別動態地添加方法。例如：<br>
      </small>
      <pre>class Some:<br>    def __init__(self, x):<br>        self.x = x<br>        <br>s = Some(1)<br>Some.service = lambda self, y: print('do service...', self.x + y)<br>s.service(2)    # do service... 3<br></pre>
      <small><span style="font-family: Courier New,Courier,monospace;">
      <br>
      </span></small><small style="font-family: Courier New,Courier,monospace;">如果你要刪除物件上的某個特性，則可以使用<span style="font-weight: bold;">del</span>。例如：</small><small><br></small>
      
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">









        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; class Some:<br>
...&nbsp;&nbsp;&nbsp;&nbsp; pass<br>
...<br>
&gt;&gt;&gt; s = Some()<br>
&gt;&gt;&gt; s.x = 10<br>
&gt;&gt;&gt; print(s.__dict__)<br>
</span>{'x': 10}<span style="font-weight: bold;"><br>
&gt;&gt;&gt; del s.x<br>
&gt;&gt;&gt; print(s.__dict__)<br>
            </span>{}<span style="font-weight: bold;"><br>
&gt;&gt;&gt;</span><span style="font-weight: bold;"></span></span></small></td></tr></tbody>
      </table>
      <br>
      <small><span style="font-family: Courier New,Courier,monospace;">如果你試著在實例上呼叫某個方法，而該實例上沒有該綁定方法時（被@staticmethod或@classmethod修飾的函式），則會試著去類別__dict__中尋找，並以類別呼叫方式來執行函式。例如：</span></small><small><br></small>
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">









        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; class Some:<br>
...&nbsp;&nbsp;&nbsp;&nbsp; @staticmethod<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def service():<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('XD')<br>
...<br>
&gt;&gt;&gt; s = Some()<br>
&gt;&gt;&gt; s.service()<br>
</span>XD<span style="font-weight: bold;"><br>
&gt;&gt;&gt;</span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      </table>




      <br>
      <small style="font-family: Courier New,Courier,monospace;">在上例中，嘗試執行s.service()，由於s並沒有service()的綁定方法（因為被@staticmethod修飾），所以嘗試尋找Some.service()執行。<br>
      <br>
實際上，<span style="font-weight: bold;">如果嘗試透過實例取得某個特性，如果實例的__dict__中沒有，則到產
生實例的類別__dict__中尋找，如果類別__dict__仍沒有，則會試著呼叫__getattr__()來傳回，如果沒有定義
__getattr__()方法，則會引發AttributeError，如果有__getattr__()，則看__getattr__()如何處理</span>。例如：</small><br>
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">










        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; class Some:<br>
...&nbsp;&nbsp;&nbsp;&nbsp; w = 10<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def __getattr__(self, name):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if name == 'w':<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 20<br>
...<br>
&gt;&gt;&gt; s = Some()<br>
&gt;&gt;&gt; s.w<br>
</span>10<span style="font-weight: bold;"><br>
&gt;&gt;&gt; s.x<br>
&gt;&gt;&gt; class Some:<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def __getattr__(self, name):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if name == 'w':<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 20<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise AttributeError(name)<br>
...<br>
&gt;&gt;&gt; s = Some()<br>
&gt;&gt;&gt; s.w<br>
            </span>20<span style="font-weight: bold;"><br>
&gt;&gt;&gt; s.x<br>
            </span>Traceback (most recent call last):<br>
&nbsp; File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br>
&nbsp; File "&lt;stdin&gt;", line 6, in __getattr__<br>
AttributeError: x<br>
            <span style="font-weight: bold;">&gt;&gt;&gt;</span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      </table>





      <br>
      <small style="font-family: Courier New,Courier,monospace;">在類別中的函式執行過程中若有定義實例特性時，具特性名稱是以__開頭，則該名稱會被加工處理。例如：</small><small><br></small>
      
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">










        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; class Some:<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.__x = 10<br>
...<br>
&gt;&gt;&gt; s = Some()<br>
&gt;&gt;&gt; s.__x</span><br>
Traceback (most recent call last):<br>
&nbsp; File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br>
AttributeError: 'Some' object has no attribute '__x'<span style="font-weight: bold;"><br>
&gt;&gt;&gt; print(s.__dict__)<br>
            </span>{'_Some__x': 10}<span style="font-weight: bold;"><br>
&gt;&gt;&gt; s._Some__x<br>
            </span>10<span style="font-weight: bold;"><br>
&gt;&gt;&gt;</span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      
      </table>





      <br>
      <small style="font-family: Courier New,Courier,monospace;">實例變數若以__name這樣的名稱，則會自動轉換為「_類別名__name」這樣的名稱儲存在實例的__dict__中，以__開頭的變數名稱，</small><small>Python</small><small style="font-family: Courier New,Courier,monospace;">沒有真正阻止你存取它，但</small><small style="font-family: Courier New,Courier,monospace;">這提示不希望你直接存取。</small><br>
      <small style="font-family: Courier New,Courier,monospace;">
      <br>
如果不想要直接使用實例的__dict__來取得特性字典物件，則可以使用<span style="font-weight: bold;">vars()</span>，vars()會代為呼叫實例的__dict__。例如：</small><small><br></small>
      
      
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">











        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; class Some:<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.x = 10<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.y = 20<br>
...<br>
&gt;&gt;&gt; s = Some()<br>
&gt;&gt;&gt; vars(s)<br>
</span>{'y': 20, 'x': 10}<span style="font-weight: bold;"><br>
</span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span></span></small><span style="color: rgb(255, 255, 255);">&gt;&gt;&gt;<br>




            </span></td></tr></tbody>
      
      
      </table>






      <br>
      <small style="font-family: Courier New,Courier,monospace;"><br>
      </small><br>
</td>

    </tr>

  </tbody>
</table>

<br>
<br>

<br>

<br>







<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script></body>
<!-- Mirrored from openhome.cc/Gossip/Python/PropertyNameSpace.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:15:42 GMT -->
</html>