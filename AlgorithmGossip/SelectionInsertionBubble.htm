<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/AlgorithmGossip/SelectionInsertionBubble.htm by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:04:55 GMT -->
<head>






















  
  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">






  
  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">






  
  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>選擇、插入、氣泡排序</title></head><body>






<h3><a href="../index.html">From
Gossip@Openhome</a></h3>







<h1><a href="index-2.html">Algorithm Gossip:&nbsp;選擇、插入、氣泡排序</a></h1>


<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">


  <tbody>


    <tr>


      <td style="width: 676px; vertical-align: top;"> 




      
      <h2>說明</h2>

      <small>
選擇排序（Selection sort）、插入排序（Insertion sort）與氣泡排序（Bubble sort）是初學排序所必須知道的三個基本排序方式，它們由於速度不快而不實用（平均與最快的時間複雜度都是O(n<sup>2</sup>)），然而排序的方式確是值得觀察與探討的。</small><br>


      
      <h2>解法</h2>


      
      <ul>

        <li><small>選擇排序</small></li>

      
      </ul>


      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold;">將要排序的對象分作兩部份，一個是已排序的，一個是未排序的。</span>如果排序是由小而大，從後端未排序部份選擇一個最小值，並放入前端已排序部份的最後一個。例如：<br>


      </small></div>


      <small><br>

      </small>
      
      <div style="margin-left: 40px;"><small>排序前：70 80 31 37 10 1 48 60 33 80<br>


      <br>


      </small>
      
      <ol>

        <li><small>[1] 80 31 37 10 70 48 60 33 80；選出最小值1</small></li>

        <li><small>[1 10] 31 37 80 70 48 60 33 80；選出最小值10</small></li>

        <li><small>[1 10 31] 37 80 70 48 60 33 80；選出最小值31</small></li>

        <li><small>[1 10 31 33] 80 70 48 60 37 80 ......</small></li>

        <li><small>[1 10 31 33 37] 70 48 60 80 80 ......</small></li>

        <li><small>[1 10 31 33 37 48] 70 60 80 80 ......</small></li>

        <li><small>[1 10 31 33 37 48 60] 70 80 80 ......</small></li>

        <li><small>[1 10 31 33 37 48 60 70] 80 80 ......</small></li>

        <li><small>[1 10 31 33 37 48 60 70 80] 80 ......</small></li>

      
      </ol>

      <small>
      </small></div>


      <small><br>

      </small>
      
      <ul>

        <li><small>插入排序</small></li>

      
      </ul>


      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold;">將要排序的對象分作兩部份，一個是已排序的，一個是未排序的。</span></small><small>每次從後端未排序部份取得最前端的值，然後插入前端已排序部份的適當位置。例如：<br>


      </small></div>


      <small><br>

      </small>
      
      <div style="margin-left: 40px;"><small>排序前：92 77 67 8 6 84 55 85 43 67<br>


      <br>


      </small>
      
      <ol>

        <li><small>[77 92] 67 8 6 84 55 85 43 67；將77插入92前</small></li>

        <li><small>[67 77 92] 8 6 84 55 85 43 67；將67插入77前</small></li>

        <li><small>[8 67 77 92] 6 84 55 85 43 67；將8插入67前</small></li>

        <li><small>[6 8 67 77 92] 84 55 85 43 67；將6插入8前</small></li>

        <li><small>[6 8 67 77 84 92] 55 85 43 67；將84插入92前</small></li>

        <li><small>[6 8 55 67 77 84 92] 85 43 67；將55插入67前</small></li>

        <li><small>[6 8 55 67 77 84 85 92] 43 67 ......</small></li>

        <li><small>[6 8 43 55 67 77 84 85 92] 67 ......</small></li>

        <li><small>[6 8 43 55 67 67 77 84 85 92] ......</small></li>

      
      </ol>

      <small>
      </small></div>


      <small><br>

      </small>
      
      <ul>

        <li><small>氣泡排序法</small></li>

      
      </ul>


      
      


      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold;">將要排序的對象分作兩部份，一個是已排序的，一個是未排序的。</span></small><small>排序時若是從小到大，最大元素會如同氣泡一樣移至右端，其利用比較相鄰元素的方式，將較大元素交換至右端，所以較大的元素會不斷往右移動，直到適當的位置為止。


      


      


<br>

      </small><small><br>


排序前：95 27 90 49 80 58 6 9 18 50<br>

      <br>

      </small></div><div style="margin-left: 40px;">


      
      <ol>

        <li><small>27 90 49 80 58 6 9 18 50 [95]；95浮出</small></li>

        <li><small>27 49 80 58 6 9 18 50 [90 95]；90浮出</small></li>

        <li><small>27 49 58 6 9 18 50 [80 90 95]；80浮出</small></li>

        <li><small>27 49 6 9 18 50 [58 80 90 95] ......</small></li>

        <li><small>27 6 9 18 49 [50 58 80 90 95] ......</small></li>

        <li><small>6 9 18 27 [49 50 58 80 90 95] ......</small></li>

        <li><small>6 9 18 [27 49 50 58 80 90 95] ......<br>
</small></li>
        <li><small>6 9 [18 27 49 50 58 80 90 95] ......</small></li>
        <li><small>6 [9 18 27 49 50 58 80 90 95] ...... </small></li>
        <li><small>[6 9 18 27 49 50 58 80 90 95] ...... </small></li>


      
      </ol>


      <br>
      <small>基本的氣泡排序法可以利用旗標方式稍微減少比較的時間，當尋訪完未排序部份都沒有發生任何交換動作，表示排序已經完成，而無需再進行之後的迴圈比較與交換動作。</small><small></small><br>


      </div>



      <br>


      
      <h2> 實作：<a href="#C">C</a>&nbsp;&nbsp; &nbsp;<a href="#Java">Java</a>&nbsp;&nbsp; &nbsp;<a href="#Python">Python</a>&nbsp;&nbsp; &nbsp;<a href="#Scala">Scala</a>&nbsp;&nbsp;&nbsp; <a href="#Ruby">Ruby</a>&nbsp;&nbsp;&nbsp; <a href="#JavaScript">JavaScript</a>&nbsp;&nbsp;&nbsp; <a href="#Haskell">Haskell</a><br>
      </h2>



      
      <ul>

        <li><a name="C"></a> C
  </li>

      
      </ul>



      
      <pre>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#define LEN 8 <br>#define SWAP(x,y) {int t; t = x; x = y; y = t;} <br><br>void selectionSort(int*, int, int(*)(int, int));<br>void insertionSort(int*, int, int(*)(int, int));<br>void bubbleSort(int*, int, int(*)(int, int));<br><br>void print(int*, int len);<br>int ascending(int, int);<br>int descending(int, int);<br><br>int main(void) {  <br>    int number[LEN] = {10, 9, 1, 2, 5, 3, 8, 7}; <br>    <br>    selectionSort(number, LEN, ascending);<br>    print(number, LEN);<br>    <br>    insertionSort(number, LEN, descending);<br>    print(number, LEN);<br>    <br>    bubbleSort(number, LEN, ascending);<br>    print(number, LEN);<br>        <br>    return 0; <br>} <br><br>int selectedIdx(int* arr, int from, int to, int(*compar)(int, int)) {<br>    int selected = from;<br>    int i;<br>    for(i = from + 1; i &lt; to; i++) if(compar(arr[i], arr[selected]) &lt; 0) {<br>        selected = i;<br>    }<br>    return selected;<br>}<br><br>void selectionSort(int* arr, int len, int(*compar)(int, int)) { <br>    int i;<br>    for(i = 0; i &lt; len; i++) {<br>        int selected = selectedIdx(arr, i, len, compar);<br>        if(selected != i) { SWAP(arr[i], arr[selected]) }<br>    }<br>} <br><br>int insertedIdx(int* arr, int eleIdx, int(*compar)(int, int)) {<br>    int i;<br>    for(i = 0; i &lt; eleIdx; i++) if(compar(arr[i], arr[eleIdx]) &gt; 0) { <br>        break; <br>    }<br>    return i;<br>}<br><br>void insert(int* arr, int eleIdx, int inserted) {<br>    int ele = arr[eleIdx];<br>    int i;<br>    for(i = eleIdx; i &gt; inserted; i--) { arr[i] = arr[i - 1]; }<br>    arr[inserted] = ele; <br>}<br> <br>void insertionSort(int* arr, int len, int(*compar)(int, int)) {<br>    int i;<br>    for(i = 0; i &lt; len; i++) {<br>        int inserted = insertedIdx(arr, i, compar);<br>        if(inserted != i) { insert(arr, i, inserted); }<br>    }<br>}<br><br>void bubbleTo(int* arr, int to, int(*compar)(int, int)) {<br>    int i;<br>    for(i = 0; i &lt; to - 1; i++) if(compar(arr[i + 1], arr[i]) &lt; 0) {<br>        SWAP(arr[i + 1], arr[i]);<br>    }<br>}<br><br>void bubbleSort(int* arr, int len, int(*compar)(int, int)) {<br>    int i;<br>    for(i = 0; i &lt; len; i++) { bubbleTo(arr, len - i, compar); }<br>}<br><br>void print(int* arr, int len) {<br>    int i;<br>    for(i = 0; i &lt; len; i++) { printf("%d ", arr[i]); } <br>    printf("\n");<br>}<br><br>int ascending(int a, int b) { return a - b; }<br>int descending(int a, int b) { return -ascending(a, b); }<br></pre>



      
      



      
      <br><ul>

        <li><a name="Java"></a> Java
  </li>

      
      </ul>



      
      <pre>import java.util.*;<br>import static java.lang.System.out;<br>import static java.util.Collections.swap;<br><br>public class Sort {<br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; <br>        int ascending(T t1, T t2) {  return t1.compareTo(t2); }<br><br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; <br>        int descending(T t1, T t2) { return -ascending(t1, t2); }<br>    <br>    private static &lt;T&gt; int selectedIdx(List&lt;T&gt; list, <br>                         int from, int to, Comparator&lt;? super T&gt; c) {<br>        int selected = from;<br>        for(int i = from + 1; i &lt; to; i++) {<br>            if(c.compare(list.get(i), list.get(selected)) &lt; 0) { <br>                selected = i; <br>            }<br>        }<br>        return selected;<br>    }<br>    <br>    public static &lt;T&gt; void selectionSort(<br>                        List&lt;T&gt; list, Comparator&lt;? super T&gt; c) {<br>        for(int i = 0; i &lt; list.size(); i++) {<br>            int selected = selectedIdx(list, i, list.size(), c);<br>            if(selected != i) { swap(list, i, selected); }<br>        }<br>    }<br>    <br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void selectionSort(<br>                       List&lt;T&gt; list) { <br>        selectionSort(list, Sort::ascending); <br>    }<br>    <br>    private static &lt;T&gt; int insertedIdx(<br>                     List&lt;T&gt; list, int eleIdx, Comparator&lt;? super T&gt; c) {<br>        int i;<br>        for(i = 0; i &lt; eleIdx; i++) {<br>            if(c.compare(list.get(i), list.get(eleIdx)) &gt; 0) { break; }<br>        }<br>        return i;<br>    }<br>    <br>    public static &lt;T&gt; void insertionSort(<br>              List&lt;T&gt; list, Comparator&lt;? super T&gt; c) {<br>        for(int i = 0; i &lt; list.size(); i++) {<br>            int inserted = insertedIdx(list, i, c);<br>            if(inserted != i) { <br>                list.add(inserted, list.remove(i));<br>            }<br>        }    <br>    }<br>    <br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; <br>        void insertionSort(List&lt;T&gt; list) { <br>            insertionSort(list, Sort::ascending); <br>        }<br>    <br>    public static &lt;T&gt; void bubbleTo(<br>                List&lt;T&gt; list, int to, Comparator&lt;? super T&gt; c) {<br>        for(int i = 0; i &lt; to - 1; i++) {<br>            if(c.compare(list.get(i + 1), list.get(i)) &lt; 0) {<br>                swap(list, i + 1, i);<br>            }<br>        }<br>    }<br>    <br>    public static &lt;T&gt; void bubbleSort(<br>        List&lt;T&gt; list, Comparator&lt;? super T&gt; c) {<br>            for(int i = 0; i &lt; list.size(); i++) { <br>                bubbleTo(list, list.size() - i, c); <br>            }<br>    }<br>    <br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; <br>        void bubbleSort(List&lt;T&gt; list) { bubbleSort(list, Sort::ascending); }<br>    <br>    <br>    public static void main(String[] args) {<br>        List&lt;Integer&gt; list = <br>            new ArrayList&lt;&gt;(Arrays.asList(10, 9, 1, 2, 5, 3, 8, 7));<br>        <br>        selectionSort(list);<br>        out.println(list);<br>        <br>        insertionSort(list, Sort::descending);<br>        out.println(list);<br>        <br>        bubbleSort(list);<br>        out.println(list);<br>    }<br>}<br></pre><br><ul><li><a name="Python"></a>Python</li></ul><pre>from functools import reduce<br><br>def ascending(a, b): return a - b<br>def descending(a, b): return -ascending(a, b)<br>    <br>def selectionSort(xs, compare = ascending):<br>    return [] if not xs else __select(xs, compare)<br><br>def __select(xs, compare):<br>    selected = reduce(<br>        lambda m, k: m if compare(m, k) &lt; 0 else k, xs)<br>    remain = [elem for elem in xs if elem != selected]<br>    return (xs if not remain<br>               else [elem for elem in xs if elem == selected] <br>                   + __select(remain, compare))<br><br>def insertionSort(xs, compare = ascending):<br>    return ([] if not xs<br>               else __insert(xs[0], <br>                   insertionSort(xs[1:], compare), compare))<br>        <br>def __insert(x, xs, compare):<br>    return ([x] + xs if not xs or compare(x, xs[0]) &lt;= 0<br>                     else [xs[0]] + __insert(x, xs[1:], compare))<br><br>def bubbleSort(xs, compare = ascending):<br>    return [] if not xs else __up(xs, compare)<br>        <br>def __up(xs, compare):<br>    if not xs[1:]: <br>        return xs<br>    else:<br>        s = bubbleSort(xs[1:], compare)<br>        return ([s[0]] + __up([xs[0]] + s[1:], compare) <br>                    if compare(xs[0], s[0]) &gt; 0<br>                    else [xs[0]] + s)<br><br>list = [10, 9, 1, 2, 5, 3, 8, 7]<br><br>print(selectionSort(list))<br>print(insertionSort(list, descending))<br>print(bubbleSort(list))<br></pre><br><ul><li><a name="Scala"></a>Scala</li></ul><pre>object Sort {<br>    def selection[T](xs: List[T], compare: (T, T) =&gt; Boolean): List[T] = {<br>        if(xs.isEmpty) Nil<br>        else select(xs, compare)<br>    }<br>    private def select[T](xs: List[T], <br>                  compare: (T, T) =&gt; Boolean): List[T] = {<br>        val selected = xs.reduceLeft((m, k) =&gt; if(compare(m, k)) m else k)<br>        val remain = xs.filter(_ != selected)<br>        if(remain.isEmpty) xs<br>        else xs.filter(_ == selected) ++ select(remain, compare)           <br>    }<br>    <br>    def insertion[T](xs: List[T], compare: (T, T) =&gt; Boolean): List[T] = {<br>        if(xs.isEmpty) Nil<br>        else insert(xs.head, insertion(xs.tail, compare), compare)<br>    }<br>    private def insert[T](x: T, xs: List[T], <br>                    compare: (T, T) =&gt; Boolean): List[T] = {<br>        if(xs.isEmpty || x == xs.head || compare(x, xs.head)) x :: xs<br>        else xs.head :: insert(x, xs.tail, compare)<br>    }<br>    <br>    def bubble[T](xs: List[T], compare: (T, T) =&gt; Boolean):List[T] = {<br>        if(xs.isEmpty) Nil<br>        else up(xs, compare)<br>    }<br>    private def up[T](xs: List[T], <br>                   compare: (T, T) =&gt; Boolean): List[T] = {<br>        if(xs.tail.isEmpty) xs<br>        else {<br>            val s = bubble(xs.tail, compare)<br>            if(!compare(xs.head, s.head)) <br>                s.head :: up(xs.head :: s.tail, compare)<br>            else xs.head :: s<br>        }<br>    }<br>}<br><br>val list = List(10, 9, 1, 2, 5, 3, 8, 7)<br><br>println(Sort.selection[Int](list, _ &gt; _))<br>println(Sort.insertion[Int](list, _ &lt; _))<br>println(Sort.bubble[Int](list, _ &gt; _))</pre><br>
      <ul>
        <li><a name="Ruby"></a>Ruby</li>
      </ul>
      <pre>class Array<br>    def comprehend(&amp;block)<br>        return self if block.nil?<br>        self.collect(&amp;block).compact<br>    end<br>end<br><br>class Sort<br>    @@ascending = -&gt;(a, b) { a - b }<br>    @@descending = -&gt;(a, b) { -@@ascending.call(a, b) }<br>    <br>    def self.ascending; @@ascending end<br>    def self.descending; @@descending end<br><br>    def self.selection(xs, compare)<br>        xs.empty? ? [] : select(xs, compare)<br>    end<br>    def self.select(xs, compare)<br>        selected = xs.reduce { |m, k| compare.call(m, k) &lt; 0 ? m : k }<br>        remain = xs.comprehend { |elem| elem if elem != selected}<br>        remain.empty? ? <br>            xs : xs.comprehend { <br>                |elem| elem if elem == selected} + select(remain, compare<br>            )<br>    end<br>    private_class_method :select<br>    <br>    def self.insertion(xs, compare)<br>        xs.empty? ? [] : insert(<br>            xs[0], insertion(xs[1..-1], compare), compare)<br>    end<br>    def self.insert(x, xs, compare)<br>        xs.empty? || compare.call(x, xs[0]) &lt;= 0 ?<br>            [x] + xs : [xs[0]] + insert(x, xs[1..-1], compare)<br>    end<br>    private_class_method :insert<br>    <br>    def self.bubble(xs, compare)<br>        xs.empty? ? [] : up(xs, compare)<br>    end<br>    def self.up(xs, compare)<br>        if xs[1..-1].empty?<br>            xs<br>        else<br>            s = bubble(xs[1..-1], compare)<br>            compare.call(xs[0], s[0]) &gt; 0 ? <br>                [s[0]] + up([xs[0]] + s[1..-1], compare) : [xs[0]] + s<br>        end<br>    end<br>    private_class_method :up<br>end<br><br>list = [10, 9, 1, 2, 5, 3, 8, 7]<br>print(Sort.selection(list, Sort.ascending).to_s + "\n")<br>print(Sort.insertion(list, Sort.descending).to_s + "\n")<br>print(Sort.bubble(list, Sort.ascending).to_s + "\n")<br></pre>
      <br>
      <ul>
        <li><a name="JavaScript"></a>JavaScript</li>
      </ul>
      <pre>function swap(list, i, j) {<br>    var ele = list[i];<br>    list[i] = list[j];<br>    list[j] = ele;<br>}<br><br>function ascending(a, b) {return a - b;}<br>function descending(a, b) {return -ascending(a, b);}<br><br>function selectedIdx(list, from, to, compare) {<br>    var selected = from;<br>    for(var i = from + 1; i &lt; to; i++) {<br>        if(compare(list[i], list[selected]) &lt; 0) { <br>            selected = i; <br>        }<br>    }<br>    return selected;<br>}<br>    <br>function selectionSort(list, compare) {<br>    for(var i = 0; i &lt; list.length; i++) {<br>        var selected = selectedIdx(list, i, list.length, compare);<br>        if(selected !== i) { swap(list, i, selected); }<br>    }<br>}<br><br>function insertedIdx(list, eleIdx, compare) {<br>    for(var i = 0; i &lt; eleIdx; i++) {<br>        if(compare(list[i], list[eleIdx]) &gt; 0) { break; }<br>    }<br>    return i;<br>}<br><br>function insert(list, eleIdx, inserted) {<br>    var ele = list[eleIdx];<br>    for(var i = eleIdx; i &gt; inserted; i--) { list[i] = list[i - 1]; }<br>    list[inserted] = ele; <br>}<br><br>function insertionSort(list, compare) {<br>    for(var i = 0; i &lt; list.length; i++) {<br>        var inserted = insertedIdx(list, i, compare);<br>        if(inserted !== i) { insert(list, i, inserted); }<br>    }    <br>}<br><br>function bubbleTo(list, to, compare) {<br>    for(var i = 0; i &lt; to - 1; i++) if(compare(list[i + 1], list[i]) &lt; 0) {<br>        swap(list, i + 1, i);<br>    }<br>}<br>    <br>function bubbleSort(list, compare) {<br>    for(var i = 0; i &lt; list.length; i++) { <br>        bubbleTo(list, list.length - i, compare); <br>    }<br>}<br><br>var list = [10, 9, 1, 2, 5, 3, 8, 7];<br><br>selectionSort(list, ascending);<br>print(list);<br><br>insertionSort(list, descending);<br>print(list);<br><br>bubbleSort(list, ascending);<br>print(list);<br></pre>
      <br>
      <ul>
        <li><a name="Haskell"></a>Haskell</li>
      </ul>
      <pre>ascending a b = a - b<br>descending a b = -ascending a b<br><br>select xs compare =<br>    if remain == [] <br>        then xs<br>        else [elem | elem &lt;- xs, elem == selected] ++ select remain compare<br>    where<br>        selected = foldl1 (\m k -&gt; if compare m k &lt; 0 then m else k) xs<br>        remain = [elem | elem &lt;- xs, elem /= selected]<br><br>selectionSort xs compare =<br>    if xs == [] then [] else select xs compare<br><br>insert x xs compare =<br>    if xs == [] || (compare x $ head xs) &lt;= 0<br>        then x : xs<br>        else head xs : insert x (tail xs) compare<br><br>insertionSort xs compare =<br>    if xs == [] <br>        then []<br>        else insert (head xs) (insertionSort (tail xs) compare) compare<br><br>up xs compare =<br>    if tail xs == []<br>        then xs<br>        else<br>            let s = bubbleSort (tail xs) compare<br>            in if compare (head xs) (head s) &gt; 0<br>                    then head s : up (head xs : tail s) compare<br>                    else head xs : s<br><br>bubbleSort xs compare =<br>    if xs == [] then [] else up xs compare<br><br>main = sequence [print $ sort list ascending| sort &lt;- sorts]<br>    where list = [10, 9, 1, 2, 5, 3, 8, 7]<br>          sorts = [selectionSort, insertionSort, bubbleSort]<br></pre>
<br>

 </td>


      <td style="width: 250px; text-align: center; vertical-align: top;"><comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>&nbsp;
      
      
      
      
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      
      
      
      
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>





      <br>





      
      
      
      
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      
      
      
      
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>


      
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      
      
      
      
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>





      <br>




      
      
      
      
      <center>
      
      
      
      
       <br>





      </center>





 </td>


    </tr>


  
  </tbody>
</table>


<br>

<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script>
</body>
<!-- Mirrored from openhome.cc/Gossip/AlgorithmGossip/SelectionInsertionBubble.htm by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:04:55 GMT -->
</html>