<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/AlgorithmGossip/ShellSort.htm by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:04:55 GMT -->
<head>














  
  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">






  
  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">






  
  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>Shell 排序法 - 改良的插入排序</title></head><body>






<h3><a href="../index.html">From
Gossip@Openhome</a></h3>






<h1><a href="index-2.html">Algorithm Gossip: Shell 排序法 - 改良的插入排序</a></h1>


<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">


  <tbody>


    <tr>


      <td style="width: 676px; vertical-align: top;"> 
      
      <h2>說明</h2>

      <small>
插入排序法由未排序的後半部前端取出一個值，插入已排序前半部的適當位置，概念簡單但速度不快。<br>

      <br>


排序加快的原則之一，是讓後一次排序進行時，儘量利用前次排序後的結果，Shell排序法就是基於此概念來改良插入排序法。</small>
      <br>


      
      <h2>解法</h2>

      <small>
Shell排序法最初是D.L Shell於1959提出。假設要排序元素有n個，每次插入排序時並不是針對所有元素，而是取一段間隔。<br>

      <br>


Shell首先將間隔設為n/2，然後跳躍進行插入排序，再來將間隔設為n/4，跳躍進行排序動作，再來間隔設定為n/8、n/16，直到間隔為1的最
後一次排序終止，由於上一次排序動作都會將固定間隔的元素排好，所以間隔越來越小時，某些元素位於正確位置的機率越高，因此最後幾次排序次數將
可以大幅減低。<br>

      <br>


舉例來說，假設未排序數字如右：89、12、65、97、61、81、27、2、61、98。<br>

      <br>


數字共有10個，第一次先將間隔設為10 / 2 = 5，此時對間隔為5的數字進行排序，如下所示：</small>


      <br>



      <img style="width: 225px; height: 95px;" alt="Shell 排序" title="Shell 排序" src="images/shellSort-1.jpg"><br>


      
      <div style="text-align: left;"></div>


      <small>畫線連結部份表示 要一起進行排序的部份，再來將間隔設定為5 / 2的商，也就是2，則第二次插入排序對象如下所示：</small><br>


      
      <div style="text-align: center;"><img style="width: 229px; height: 74px;" alt="Shell 排序" title="Shell 排序" src="images/shellSort-2.jpg"><br>


      </div>


      <br>

      <small>

再來間隔設定為2 / 2 = 1，此時就是單純插入排序了，由於大部份元素已大致排序過，所以最後一次的插入排序幾乎沒作什麼動作： </small><br>


      
      <div style="text-align: center;"><img style="width: 225px; height: 66px;" alt="Shell 排序" title="Shell 排序" src="images/shellSort-3.jpg"><br>


      <br>


      </div>

      <small>

將間隔設定為n / 2是D.L
Shell最初所提出，在教科書中使用這個間隔比較好說明，然而Shell排序法的關鍵在於間隔的選定，例如Sedgewick證明選用以下的間隔可以加
快Shell排序法速度：</small> <br>


      
      <div style="text-align: center;"><img style="width: 184px; height: 94px;" alt="Shell 排序" title="Shell 排序" src="images/shellSort-4.jpg"><br>


      </div>

      <small>

其中4*(2<sup>j</sup>)<sup>2</sup> + 3*(2<sup>j</sup>) + 1不可超過元素總數n值，使用上式找出j後代入4*(2<sup>j</sup>)<sup>2</sup> + 3*(2<sup>j</sup>) + 1求得第一個間隔，然後將2<sup>j</sup>除以2代入求得第二個間隔，再來依此類推。 <br>

      <br>


後來還有人證明有其它間隔選定法可再加快Shell排序法；Shell排序法概念也可以用來改良氣泡排序法。</small>

      <br>


      
      <h2> 實作：<a href="#C">C</a>&nbsp;&nbsp; &nbsp;<a href="#Java">Java</a>&nbsp;&nbsp; &nbsp;<a href="#Python">Python</a>&nbsp;&nbsp; &nbsp;<a href="#Scala">Scala</a>&nbsp;&nbsp;&nbsp; <a href="#Ruby">Ruby</a>&nbsp;&nbsp;&nbsp; <a href="#JavaScript">JavaScript</a>&nbsp;&nbsp;&nbsp; <a href="#Haskell">Haskell</a><br>
      </h2>



      
      <ul>

        <li><a name="C"></a> C
  </li>

      
      </ul>



      
      <pre>#include &lt;stdio.h&gt; <br>#define LEN 10<br>#define SWAP(x,y) {int t; t = x; x = y; y = t;} <br><br>void sort(int*, int, int(*)(int, int));<br>void insertion(int*, int, int, int, int(*)(int, int));<br>void insert(int*, int, int, int, int(*)(int, int));<br>int ascending(int, int);<br>int descending(int, int);<br>void print(int*, int);<br><br>int main(void) { <br>    int number[LEN] = {89, 12, 65, 97, 61, 81, 27, 2, 61, 98}; <br>    <br>    sort(number, LEN, ascending); <br>    print(number, LEN);<br>    <br>    sort(number, LEN, descending); <br>    print(number, LEN);<br><br>    return 0; <br>} <br><br>void sort(int* number, int len, int(*compar)(int, int)) {<br>    int gap;<br>    for(gap = len / 2; gap &gt; 0; gap /= 2) {<br>        int begin;<br>        for(begin = 0; begin &lt; gap; begin++) { <br>            insertion(number, len, begin, gap, compar);<br>        }<br>    }<br>}<br><br>void insertion(int* number, int len, <br>               int begin, int gap, int(*compar)(int, int)) {<br>    int i;<br>    for(i = begin + gap; i &lt; len; i += gap) { <br>        insert(number, begin, gap, i, compar); <br>    } <br>}<br><br>void insert(int* number, int begin, int gap, int i, int(*compar)(int, int)) {<br>    int j;<br>    for(j = i - gap; <br>        j &gt;= begin &amp;&amp; compar(number[j], number[j + gap]) &gt; 0 ; j -= gap) { <br>        SWAP(number[j], number[j + gap]); <br>    }<br>}<br><br>void print(int* arr, int len) {<br>    int i;<br>    for(i = 0; i &lt; len; i++) { printf("%d ", arr[i]); } <br>    printf("\n");<br>}<br><br>int ascending(int a, int b) { return a - b; }<br>int descending(int a, int b) { return -ascending(a, b); }<br></pre>



      <br>



      
      <ul>

        <li><a name="Java"></a> Java
  </li>

      
      </ul>



      
      <pre>import java.util.*;<br>import static java.lang.System.out;<br>import static java.util.Collections.swap;<br><br>public class Sort {<br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; <br>        int ascending(T t1, T t2) {  return t1.compareTo(t2); }<br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; <br>        int descending(T t1, T t2) { return -ascending(t1, t2); }<br><br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void shellSort(<br>                       List&lt;T&gt; list) { <br>        shellSort(list, Sort::ascending); <br>    }<br>    <br>    public static &lt;T&gt; void shellSort(<br>                        List&lt;T&gt; list, Comparator&lt;? super T&gt; c) {<br>        for(int gap = list.size() / 2; gap &gt; 0; gap /= 2) {<br>            for(int begin = 0; begin &lt; gap; begin++) { <br>                insertionSort(list, begin, gap, c);<br>            }<br>        }<br>    }<br>    <br>    private static &lt;T&gt; void insertionSort(<br>             List&lt;T&gt; list, int begin, int gap, Comparator&lt;? super T&gt; c) {<br>        for(int i = begin + gap; i &lt; list.size(); i += gap) { <br>            insert(list, begin, gap, i, c); <br>        } <br>    }<br>    <br>    private static &lt;T&gt; void insert(<br>                List&lt;T&gt; list, int begin, int gap, <br>                int i, Comparator&lt;? super T&gt; c) {<br>        for(int j = i - gap; <br>            j &gt;= begin &amp;&amp; c.compare(<br>            list.get(j), list.get(j + gap)) &gt; 0 ; j -= gap) { <br>            swap(list, j, j + gap);<br>        }<br>    }<br><br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; <br>        void insertionSort(List&lt;T&gt; list) { <br>            insertionSort(list, Sort::ascending); <br>        }<br>        <br>    public static &lt;T&gt; void insertionSort(<br>                List&lt;T&gt; list, Comparator&lt;? super T&gt; c) {<br>        insertionSort(list, 0, 1, c);<br>    }<br>    <br>    public static void main(String[] args) {<br>        List&lt;Integer&gt; list = <br>            new ArrayList&lt;&gt;(<br>                Arrays.asList(89, 12, 65, 97, 61, 81, 27, 2, 61, 98));<br>        <br>        shellSort(list);<br>        out.println(list);<br>        <br>        insertionSort(list, Sort::descending);<br>        out.println(list);<br>    }<br>}<br></pre><br><ul><li><a name="Python"></a>Python</li></ul><pre>from functools import reduce<br><br>def ascending(a, b): return a - b<br>def descending(a, b): return -ascending(a, b)<br><br>def insertionSort(xs, compare = ascending):<br>    return ([] if not xs<br>               else __insert(xs[0], <br>                   insertionSort(xs[1:], compare), compare))<br>        <br>def __insert(x, xs, compare):<br>    return ([x] + xs if not xs or compare(x, xs[0]) &lt;= 0<br>                     else [xs[0]] + __insert(x, xs[1:], compare))<br>                     <br>def bubbleSort(xs, compare = ascending):<br>    return [] if not xs else __up(xs, compare)<br>        <br>def __up(xs, compare):<br>    if not xs[1:]: <br>        return xs<br>    else:<br>        s = bubbleSort(xs[1:], compare)<br>        return ([s[0]] + __up([xs[0]] + s[1:], compare) <br>                    if compare(xs[0], s[0]) &gt; 0<br>                    else [xs[0]] + s)<br><br>def shellSort(xs, sort = insertionSort, compare = ascending):   <br>    return (reduce(lambda xs, gap: <br>        sortWith(gap, xs, sort, compare), gaps(len(list)), xs))<br>    <br>def gaps(len):<br>    gap = len // 2<br>    return [gap] + gaps(gap // 2) if gap &gt; 0 else []<br>        <br>def sortWith(gap, lt, sort, compare):<br>    sortedLts = [sort(lt[begin::gap], compare) <br>        for begin in range(0, gap)]<br>    return [elem for sortedLt in zip(*sortedLts) <br>        for elem in sortedLt]<br>                    <br>list = [89, 12, 65, 97, 61, 81, 27, 2, 61, 98]<br><br>print(shellSort(list))<br>print(shellSort(list, compare = descending))<br>print(shellSort(list, sort = bubbleSort, compare = ascending))</pre><br><ul><li><a name="Scala"></a>Scala</li></ul><pre>object Sort {<br>    def insertion[T](xs: List[T], compare: (T, T) =&gt; Boolean): List[T] = {<br>        if(xs.isEmpty) Nil<br>        else insert(xs.head, insertion(xs.tail, compare), compare)<br>    }<br>    private def insert[T](x: T, xs: List[T], <br>                    compare: (T, T) =&gt; Boolean): List[T] = {<br>        if(xs.isEmpty || x == xs.head || compare(x, xs.head)) x :: xs<br>        else xs.head :: insert(x, xs.tail, compare)<br>    }<br>    <br>    def shell[T](xs: List[T], compare: (T, T) =&gt; Boolean): List[T] =<br>        (xs /: gaps(list.size))((xs, gap) =&gt; sortWith(gap, xs, compare))<br>    <br>    private def sortWith[T](gap: Int, lt: List[T], <br>                    compare: (T, T) =&gt; Boolean): List[T] = {<br>        def subWithGap[T](lt: List[T], begin: Int): List[T] = {<br>            if(begin &gt;= lt.length) Nil<br>            else lt(begin) :: subWithGap(lt, begin + gap)<br>        }<br>        (for(begin &lt;- 0 until gap) yield <br>            insertion(subWithGap(lt, begin), compare)<br>        ).toList.transpose.flatten<br>    }<br>    <br>    private def gaps(len: Int): List[Int] = {<br>        val gap = len / 2<br>        if(gap &gt; 0) gap :: gaps(gap / 2)<br>        else Nil<br>    }   <br>}<br><br>val list = List(89, 12, 65, 97, 61, 81, 27, 2, 61, 98)<br>println(Sort.shell[Int](list, _ &gt; _))<br>println(Sort.shell[Int](list, _ &lt; _))</pre><br>
      <ul>
        <li><a name="Ruby"></a>Ruby</li>
      </ul>
      <pre>class Sort<br>    @@ascending = -&gt;(a, b) { a - b }<br>    @@descending = -&gt;(a, b) { -@@ascending.call(a, b) }<br>    <br>    def self.ascending; @@ascending end<br>    def self.descending; @@descending end<br>    <br>    def self.insertion(xs, compare)<br>        xs.empty? ? [] : insert(<br>            xs[0], insertion(xs[1..-1], compare), compare)<br>    end<br>    def self.insert(x, xs, compare)<br>        xs.empty? || compare.call(x, xs[0]) &lt;= 0 ?<br>            [x] + xs : [xs[0]] + insert(x, xs[1..-1], compare)<br>    end<br>    private_class_method :insert<br>        <br>    def self.shell(xs, compare)<br>        gaps(xs.size).reduce(xs) { |xs, gap|<br>            sortWith(gap, xs, compare)<br>        }<br>    end<br><br>    def self.gaps(len)<br>        gap = len / 2<br>        gap &gt; 0 ? [gap] + gaps(gap / 2) : []<br>    end<br>    private_class_method :gaps<br>    <br>    def self.sortWith(gap, xs, compare)<br>        subWithGap = -&gt;(xs, start) {<br>            start &gt;= xs.size ? [] : <br>                xs[start, 1] + subWithGap.call(xs, start + gap)<br>        }<br>        sorted = (0...gap).map { <br>          |start| insertion(subWithGap.call(xs, start), compare) <br>        }<br>        sorted[0].zip(*sorted[1..-1]).flatten<br>    end<br>    private_class_method :sortWith<br><br>end<br><br>list = [89, 12, 65, 97, 61, 81, 27, 2, 61, 98]<br>print(Sort.shell(list, Sort.descending).to_s + "\n")<br>print(Sort.shell(list, Sort.ascending).to_s + "\n")<br></pre>
      <br>
      <ul>
        <li><a name="JavaScript"></a>JavaScript</li>
      </ul>
      <pre>function swap(list, i, j) {<br>    var ele = list[i];<br>    list[i] = list[j];<br>    list[j] = ele;<br>}<br><br>function ascending(a, b) {return a - b;}<br>function descending(a, b) {return -ascending(a, b);}<br><br>function insert(list, begin, gap, i, compare) {<br>    for(var j = i - gap; j &gt;= begin &amp;&amp; compare(<br>            list[j], list[j + gap]) &gt; 0; j -= gap) {<br>        swap(list, j, j + gap);<br>    }<br>}<br><br>function insertionSort(list, begin, gap, compare) {<br>    for(var i = begin + gap; i &lt; list.length; i += gap) { <br>        insert(list, begin, gap, i, compare); <br>    } <br>}<br><br>function shellSort(list, compare) {<br>    for(var gap = parseInt(list.length / 2); <br>            gap &gt; 0; gap = parseInt(gap / 2)) {<br>        for(var begin = 0; begin &lt; gap; begin++) { <br>            insertionSort(list, begin, gap, compare);<br>        }<br>    }<br>}<br><br>var list = [89, 12, 65, 97, 61, 81, 27, 2, 61, 98];<br>shellSort(list, descending);<br>print(list);<br></pre>
      <br>
      <ul>
        <li><a name="Haskell"></a>Haskell</li>
      </ul>
      <pre>import Data.List (transpose)<br><br>ascending a b = a - b<br>descending a b = -ascending a b<br><br>insert x xs compare =<br>    if xs == [] || (compare x $ head xs) &lt;= 0<br>        then x : xs<br>        else head xs : insert x (tail xs) compare<br><br>insertionSort xs compare =<br>    if xs == [] <br>        then []<br>        else insert (head xs) (insertionSort (tail xs) compare) compare<br><br>gaps len =<br>    if gap &gt; 0 then gap : gaps (gap `div` 2)<br>    else []<br>    where gap = len `div` 2<br><br>sortWith gap xs compare =<br>    foldl (++) [] (transpose [insertionSort (subWithGap xs begin) compare | <br>        begin &lt;- [0 .. gap - 1]])<br>    where <br>        subWithGap xs begin =<br>            if begin &gt;= length xs then []<br>            else (xs !! begin) : subWithGap xs (begin + gap)<br><br>shellSort xs compare =<br>    foldl (\xs gap -&gt; sortWith gap xs compare) xs (gaps $ length xs)<br>    <br>main = sequence [print $ shellSort list ascending, <br>                 print $ shellSort list descending]<br>    where list = [89, 12, 65, 97, 61, 81, 27, 2, 61, 98]<br></pre>
<br>


 </td>


      <td style="width: 250px; text-align: center; vertical-align: top;"><comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>&nbsp;
      
      
      
      
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      
      
      
      
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>





      <br>





      
      
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      
      
      
      
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>





      <br>
      
      
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      
      
      
      
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>





      <br>




      
      
      
      
      <center>
      
      
      
      
       <br>





      </center>





 </td>


    </tr>


  
  </tbody>
</table>


<br>

<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script>
</body>
<!-- Mirrored from openhome.cc/Gossip/AlgorithmGossip/ShellSort.htm by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:04:56 GMT -->
</html>