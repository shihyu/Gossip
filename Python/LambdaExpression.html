<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/Python/LambdaExpression.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:15:42 GMT -->
<head>












  
  
  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">







  
  
  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">







  
  
  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>lambda 運算式</title></head><body>







<h3><a href="../index.html">From
Gossip@Openhome</a></h3>







<h1><a href="index-2.html">Python Gossip: lambda 運算式<br>
</a></h1>

<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">

  <tbody>

    <tr>

      <td style="vertical-align: top; width: 250px; text-align: center;"> <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br><br>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>

      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br><br><center> </center></td>

      <td style="vertical-align: top; width: 690px; text-align: left;"><small>在Python中，函式是一級（First-class）公民，也就是說，<span style="font-weight: bold;">在Python中，函式是物件，為<span style="font-family: Courier New,Courier,monospace;">function</span>的實例</span>。如果你要定義一個函式，基本上是使用<span style="font-family: Courier New,Courier,monospace;">def</span>來定義，如同</small><small><a href="DefStatement.html"><small> <big>def 陳述句</big></small></a> </small><small>中所說明過的，例如你要定義一個最大值的函式：<br>
      </small>
      <pre>def max(m, n):<br>    return m if m &gt; n else n<br><br>print(max(10, 3))  # 顯示 10</pre>
      <small><br>
      </small><small style="font-family: Courier New,Courier,monospace;">你可以用<span style="font-weight: bold;">lambda</span>運算式來定義函式，執行運算式時將會產生函式物件。
例如，上面的max函式，可以用以下的方式定義：</small><br>
      <pre>max = <span style="font-weight: bold;">lambda m, n: m if m &gt; n else n<br></span>print(max(10, 3))  # 顯示 10<br>      </pre>
      <br>
      <small><span style="font-family: Courier New,Courier,monospace;">lambda</span>的語法是：<br>
      </small>
      <div style="margin-left: 40px;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">lambda arg1, arg2, ....: expression</small><br>
      </div>
      <br>
      <small style="font-family: Courier New,Courier,monospace;">lambda中arg1、arg2等就相當於定義函式時的參數，之後你可以在expression中使用這些參數。</small><small>注意！<span style="font-family: Courier New,Courier,monospace;">lambda</span>是運算式，不是陳述句，你在<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">:</span>之後的也必須是運算式，<span style="font-family: Courier New,Courier,monospace;">lambda中也不能有區塊，這表示一些小的運算任務你可以使用lambda，而較複雜的邏輯你可以使用def來定義。<br>
      <br>
基本上，lambda會產生function的實例，所以在</span></small><small><big><small><a href="DefStatement.html"><small><big>def 陳述句</big></small></a> 中所提到的參數定義與引數指定方式，<span style="font-family: Courier New,Courier,monospace;">對於lambda所產生的function實例都是適用的。</span></small></big></small><br>
      <small><small><span style="font-family: Courier New,Courier,monospace;"></span><br>
      </small>在Python中缺少其它語言中的<span style="font-family: Courier New,Courier,monospace;">switch陳述句，以下結合字典物件與lambda模擬switch的示範：</span><br>
      </small>
      <pre>score = int(input('請輸入分數：'))<br>level = score // 10<br>{<br>    10 : lambda: print('Perfect'),<br>    9  : lambda: print('A'),<br>    8  : lambda: print('B'),<br>    7  : lambda: print('C'),<br>    6  : lambda: print('D')<br>}.get(level, lambda: print('E'))()<br></pre>
      <small style="font-family: Courier New,Courier,monospace;"><br>
在上例中，字典物件中的值的部份是lambda所建立的函式物件，你使用get()方法指定鍵，如果有符合的鍵，就傳回對應的函式物件並執行，否則就傳回get()第二個引數所指定的函式並執行，這模擬了switch中default的陳述。</small><br style="font-family: Courier New,Courier,monospace;">
      <br><small>在Python中，函式是<span style="font-family: Courier New,Courier,monospace;">function</span>的實例，所以你可以自由傳遞，將一個函式中所定義的函式傳回也是常見的應用。例如：<br>
      </small>
      <pre>def add(n1):<br>    def func(n2):<br>        return n1 + n2<br>    return func<br><br>print(add(1)(2))  # 顯示 3<br></pre>

      <br>
      <small>從一個函式中呼叫另一個函式，這是函式程設中<span style="font-weight: bold;">鞣制（Curry）</span>的概念。</small><small>所謂鞣製，是指將接受多個參數的函式，改為接受單一參數的函式，在函式執行過後傳回一個函式物件再套用剩下的參數，就像是將兩個函式鞣製在一起。<br>
      <br>
另一個值得注意的是，<span style="font-family: Courier New,Courier,monospace;">n1參數的存活期間，本應跟隨著add()函式呼叫完成就結束，不過因為n1被綁定在func()函式之中，</span>形成了一個<span style="font-weight: bold;">閉包（Closure）</span>。<br>
      <br>
      </small><span style="color: rgb(0, 0, 0); font-family: serif; font-size: 13.3333px; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; background-color: rgb(255, 255, 255); font-weight: bold;">閉包（Closure）</span><span style="color: rgb(0, 0, 0); font-family: serif; font-size: 13.3333px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; background-color: rgb(255, 255, 255); display: inline ! important; float: none;">是擁有</span><span style="color: rgb(0, 0, 0); font-family: serif; font-size: 13.3333px; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; background-color: rgb(255, 255, 255); font-weight: bold;">閒置變數（Free variable）</span><span style="color: rgb(0, 0, 0); font-family: serif; font-size: 13.3333px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; background-color: rgb(255, 255, 255); display: inline ! important; float: none;">的運算式。閒置變數真正扮演的角色依當時語彙環境（Lexical environment）而定。支援閉包的程式語言通常具有一級函式（First-class function）。建立函式不等於建立閉包。如果函式的閒置變數與當時語彙環境綁定，該函式才稱為閉包。</span><span style="color: rgb(0, 0, 0); font-family: serif; font-size: 13.3333px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; background-color: rgb(255, 255, 255); display: inline ! important; float: none;"></span><br>
      <br>
      <small>在Python中，確實支援閉包的概念。例如：</small><small><br></small>
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">





        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; def outer():<br>
...&nbsp;&nbsp;&nbsp;&nbsp; x = 10<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def inner():<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(x)<br>
...&nbsp;&nbsp;&nbsp;&nbsp; inner()<br>
...&nbsp;&nbsp;&nbsp;&nbsp; x = 20<br>
...&nbsp;&nbsp;&nbsp;&nbsp; return inner<br>
...<br>
&gt;&gt;&gt; f = outer()<br>
</span>10<span style="font-weight: bold;"><br>
&gt;&gt;&gt; f()<br>
            </span>20<span style="font-weight: bold;"><br>
&gt;&gt;&gt;</span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      </table>
      <br>
      <small><span style="font-family: Courier New,Courier,monospace;">在上例中，inner()確實綁定了區域變數x，在outer()內部呼叫inner()時顯示的是10，而後改變了x為20，由於inner()綁定了x，所以傳回的函式執行時，顯示x的值為20。</span><br>
      <br>
不過實際上在應用時，還是得小心一點。例如：</small><small><br></small>
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">






        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; def func():<br>
...&nbsp;&nbsp;&nbsp;&nbsp; x = 10<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def getX():<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def setX(n):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = n<br>
...&nbsp;&nbsp;&nbsp;&nbsp; return (getX, setX)<br>
...<br>
&gt;&gt;&gt; getX, setX = func()<br>
&gt;&gt;&gt; getX()<br>
</span>10<span style="font-weight: bold;"><br>
&gt;&gt;&gt; setX(20)<br>
&gt;&gt;&gt; getX()<br>
            </span>10<span style="font-weight: bold;"><br>
&gt;&gt;&gt;</span><span style="font-weight: bold;"></span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      </table>

      <br>
      <small><span style="font-family: Courier New,Courier,monospace;">在上例中，func()中的setX()宣告的x，其實是setX()中的區域變數x，其覆蓋了外部func()的x，所以你的n是指定給區域變數x。</span><br>
      <br>
回到鞣製的討論，實際上其應用，在於先針對既有的資料先行作運算並傳回未運算的函式，待後續資料備妥後再完成整個所需的運算結果。一個例子像是 </small><small><a href="../AlgorithmGossip/GCDPNumber.htm">因
式分解</a>，可以先準備好一定長度的質數表，之後利用該質數表來進行因式分解。例如：<br>
      </small>
      <pre>import math<br><br>def prepare_factor(max):<br>    prime = [1] * max<br>    for i in range(2, int(math.sqrt(max))):<br>        if prime[i] == 1:<br>            for j in range(2 * i, max):<br>                if j % i == 0:<br>                    prime[j] = 0<br>    primes = [i for i in range(2, max) if prime[i] == 1] # 質數表<br>           <br>    def factor(num):<br>        list = []<br>        i = 0<br>        while primes[i] ** 2 &lt;= num:<br>            if num % primes[i] == 0:<br>                list.append(primes[i])<br>                num //= primes[i]<br>            else:<br>                i += 1<br>        list.append(num)<br>        f = [0] * len(list)<br>        for i in range(len(f)):<br>            f[i] = list[i]<br>        return f<br>        <br>    return factor<br><br>factor = prepare_factor(1000)<br>print(factor(100))  # 顯示 [2, 2, 5, 5]<br>print(factor(500))  # 顯示 [2, 2, 5, 5, 5]<br>print(factor(800))  # 顯示 [2, 2, 2, 2, 2, 5, 5]<br></pre>
      <small><br>
      <br>
      <br>
      </small></td></tr></tbody></table></body>
<!-- Mirrored from openhome.cc/Gossip/Python/LambdaExpression.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:15:42 GMT -->
</html>