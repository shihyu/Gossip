<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/Python/SpecialMethodNames.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:15:42 GMT -->
<head>














  
  
  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">







  
  
  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">







  
  
  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>特殊方法名稱</title></head><body>







<h3><a href="../index.html">From
Gossip@Openhome</a></h3>







<h1><a href="index-2.html">Python Gossip: 特殊方法名稱<br>
</a></h1>

<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">

  <tbody>

    <tr>

      <td style="vertical-align: top; width: 250px; text-align: center;"> <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br><br>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>

      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br><br><center> </center></td>

      <td style="vertical-align: top; width: 690px; text-align: left;"><small>在Python中定義類別時，有些<span style="font-family: Courier New,Courier,monospace;">__name__</span>的特殊函式名稱，是用定義運算子或特定操作的行為。舉個例子來說，可以定義一個有理數類別，並定義其+、-、*、/等行為：<br>
      </small>
      <pre>class Rational:<br>    def __init__(self, n, d):  # 物件建立之後所要建立的初始化動作<br>        self.numer = n<br>        self.denom = d<br>    <br>    def __str__(self):   # 定義物件的字串描述<br>        return str(self.numer) + '/' + str(self.denom)<br>    <br>    def __add__(self, that):  # 定義 + 運算<br>        return Rational(self.numer * that.denom + that.numer * self.denom, <br>                        self.denom * that.denom)<br>    <br>    def __sub__(self, that):  # 定義 - 運算<br>        return Rational(self.numer * that.denom - that.numer * self.denom,<br>                        self.denom * that.denom)<br>                           <br>    def __mul__(self, that):  # 定義 * 運算<br>        return Rational(self.numer * that.numer, <br>                        self.denom * that.denom)<br>        <br>    def __truediv__(self, that):   # 定義 / 運算<br>        return Rational(self.numer * that.denom,<br>                        self.denom * that.denom)<br><br>    def __eq__(self, that):   # 定義 == 運算<br>        return self.numer * that.denom == that.numer * self.denom<br><br>x = Rational(1, 2)<br>y = Rational(2, 3)<br>z = Rational(2, 3)<br>print(x)       # 1/2<br>print(y)       # 2/3<br>print(x + y)   # 7/6<br>print(x - y)   # -1/6<br>print(x * y)   # 2/6<br>print(x / y)   # 3/6<br>print(x == y)  # False<br>print(y == z)  # True<br></pre>
      <small><br>
      <span style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">__init__()</span>定義物件建立後要執行的初始化過程，相對它的是<span style="font-weight: bold;">__del__()</span>方法，在物件被回收前會被執行（因為回收物件的時間不一定，所以不建議用在要求立即性的情況）。常見的+、-、*、/、==等操作，則分別是由<span style="font-weight: bold;">__add__()</span>、<span style="font-weight: bold;">__sub__()</span>、<span style="font-weight: bold;">__mul__()</span>、<span style="font-weight: bold;">__truediv__()</span>（//則是由<span style="font-weight: bold;">__floordiv__()</span>定義）與<span style="font-weight: bold;">__eq__()</span>定義。<br>
      <br>
      <span style="font-weight: bold;">__str__()</span>用來定義傳回物件描述字串，通常用來描述的字串是對使用者友善的說明文字，如果對物件</span></small><small><span style="font-family: Courier New,Courier,monospace;">使用str()，所呼叫的就是__str__()。如果要定義對開發人員較有意義的描述，例如傳回產生實例的類別名稱之類的，則可以定義<span style="font-weight: bold;">__repr__()</span>，如果對物件使用repr()，則所呼叫的就是__repr__()。</span></small><br>
      <small><span style="font-family: Courier New,Courier,monospace;"></span><br>
在 </small><small><big><a href="PropertyNameSpace.html"><small>特性名稱空間</small></a></big> 中看過的例子則是<span style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">__getattr__()</span>方法，相對它的方法是<span style="font-weight: bold;">__setattr__()</span></span>，而用來定義實例的特性被設定時該作什麼動作。例如：</small><small><br></small>
      
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">






        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; class Some:<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def __setattr__(self, name, value):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(name, value)<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.x = 10<br>
...<br>
&gt;&gt;&gt; s = Some()<br>
</span>x 10<span style="font-weight: bold;"><br>
&gt;&gt;&gt; s.w = 100<br>
            </span>w 100<span style="font-weight: bold;"><br>
&gt;&gt;&gt; s.__dict__['z'] = 200<br>
&gt;&gt;&gt; print(s.__dict__)<br>
            </span>{'z': 200}<span style="font-weight: bold;"><br>
&gt;&gt;&gt;</span><span style="font-weight: bold;"></span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      
      </table>

      <br>
      <small><span style="font-family: Courier New,Courier,monospace;">一旦有定義__setattr__()，則所有以<span style="font-weight: bold;"> . </span>運算子來設定特性的操作，都會呼叫__setattr__()，但直接對實例的__dict__操作則不會。<br>
      <br>
      <span style="font-weight: bold;">__getitem__()</span>與<span style="font-weight: bold;">__setitem__()</span>則用來設定[]運算子的行為。例如：</span></small><small><br></small>
      
      <table style="text-align: left; width: 100%; font-family: Courier New,Courier,monospace;" border="0" cellpadding="2" cellspacing="2">







        <tbody>




          <tr>




            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);"><span style="font-weight: bold;">&gt;&gt;&gt; class Some:<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.inner = {}<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def __setitem__(self, name, value):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.inner[name] = value<br>
...&nbsp;&nbsp;&nbsp;&nbsp; def __getitem__(self, name):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.inner[name]<br>
...<br>
&gt;&gt;&gt; s = Some()<br>
&gt;&gt;&gt; s[0] = 100<br>
&gt;&gt;&gt; s['Justin'] = 'Message'<br>
&gt;&gt;&gt; s[0]<br>
</span>100<span style="font-weight: bold;"><br>
&gt;&gt;&gt; s['Justin']<br>
            </span>'Message'<span style="font-weight: bold;"><br>
&gt;&gt;&gt;</span><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span></span></small><span style="color: rgb(255, 255, 255);"><br>




            </span></td></tr></tbody>
      
      </table>


      <br>
      <small>在設計程式的過程中，經常有的需求之一，就是希望逐一取得某物件內部的所有資料（或物件），像是取得串列中所有的資料，或取
得集合中所有的資料。</small><small><br>
<br>
因為串列是有序結構並有索引特性，而集合則為無序不重複的特性，兩者所提供的公開存取方法也不相同，</small><small>如
何以一致方式取得不同資料結構的群集物件是個問題。<br>
<br>
在Python中，你可以讓物件實作<span style="font-family: Courier New,Courier,monospace; font-weight: bold;">__iter__()</span>方法，這個方法可以傳回一個迭代器（Iterator），一個具有<span style="font-family: Courier New,Courier,monospace; font-weight: bold;">__next__()</span>方法的物件。迭代器走訪物件內容收集物件後傳回，每次呼叫迭代器物件的<span style="font-family: Courier New,Courier,monospace;">__next__()</span>方法，必須傳回群集的下一個元素，如果沒有下一個元素了，則丟出<span style="font-family: Courier New,Courier,monospace;">StopIteration</span>物件。例如：<br>
      </small>
      <pre>class Some:<br>    class Iterator:<br>        def __init__(self, length):<br>            self.length = length<br>            self.number = -1<br>        <span style="font-weight: bold;">def __next__(self):</span><br style="font-weight: bold;"><span style="font-weight: bold;">            self.number = self.number + 1</span><br style="font-weight: bold;"><span style="font-weight: bold;">            if self.number == self.length:</span><br style="font-weight: bold;"><span style="font-weight: bold;">                raise StopIteration</span><br style="font-weight: bold;"><span style="font-weight: bold;">            return self.number</span><br>    <br>    def __init__(self, length):<br>        self.length = length<br><br>    <span style="font-weight: bold;">def __iter__(self):</span><br style="font-weight: bold;"><span style="font-weight: bold;">        return Some.Iterator(self.length)</span><br><br>s = Some(3)<br>it = <span style="font-weight: bold;">iter(s)</span><br>print(<span style="font-weight: bold;">next(it)</span>)   # 0<br>print(next(it))   # 1<br>print(next(it))   # 2<br>print(next(it))   # StopIteration<br></pre>

      <small><br>
實際上，你可以使用<span style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">iter()</span>來代為呼叫物件的__iter__()方法，使用<span style="font-weight: bold;">next()</span>方法代為呼叫物件的__next__()方法</span>。事實上，你<span style="font-family: Courier New,Courier,monospace;">可以結合for in迴圈來提取物件，for in迴圈會透過__iter__()取得迭代器，然後在每次迴圈中呼叫__next__()方法，而後遇到StopIteration丟出後離開迴圈。例如：<br>
</span></small>
      <div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">for n in Some(10):</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">
<small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; print(n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 顯示 0 到 9</span></small><br>
      </div>

      <small><br>
      </small><small><span style="font-family: Courier New,Courier,monospace;"></span>以上先簡介一些簡單的特殊方法名稱，詳細的特殊方法說明，可以參考 <a href="http://docs.python.org/3/reference/datamodel.html#special-method-names">Special method names</a>。<br>
      <br>
      <br>
      </small>
</td>

    </tr>

  </tbody>
</table>

<br>
<br>

<br>

<br>







<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script></body>
<!-- Mirrored from openhome.cc/Gossip/Python/SpecialMethodNames.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:15:42 GMT -->
</html>