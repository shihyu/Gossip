<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/JavaGossip-V1/LogicalBitwiseOperator.htm by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:14:16 GMT -->
<head>




  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">




  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">




  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type">




  
  
  
  
  <title>邏輯、位元運算</title></head>
<body>




<h3><a href="../index.html">From
Gossip@Openhome</a></h3>




<h1><a href="index-2.html">Java Gossip: 邏輯、位元運算&nbsp;</a></h1>


<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">


  <tbody>


    <tr>


      <td style="width: 676px; vertical-align: top;"> <small>大於、小於的運算會了，但如果想要同時進行兩個以上的條件判斷呢？例如分數大於80但小於90的判斷，在邏輯上有所謂的「且」、「或」與「反」，在
Java中也提供這幾個基本邏輯運算所需的<span style="font-weight: bold;">「邏輯運算子」（Logical
operator）</span>，分別為<span style="font-weight: bold;">「且」（&amp;&amp;）</span>、
「<span style="font-weight: bold;">或」（||）</span>及<span style="font-weight: bold;">「反相」（!）</span>三個運算子。<br>

      <br>




來看看下面這個程式會輸出什麼？ <br>

      </small>





      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int number = 75; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">




      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">System.out.println((number
&gt; 70 &amp;&amp; number &lt; 80)); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">




      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">System.out.println((number
&gt; 80 || number &lt; 75)); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">




      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">System.out.println(!(number
&gt; 80 || number &lt; 75)); </span><br>




      </small></div>




      <small><br>




三段程式分別會輸出true、false與true三種狀況。<br>

      <br>




接下來看看<span style="font-weight: bold;">「位元運算子」（Bitwise operator）</span>，在
數位設計上有AND、OR、XOR與補數等運算，在Java中提供這些運算的就是位元運算子，它們的對應分別是<span style="font-weight: bold;"> AND （&amp;）、OR（|）、XOR（^）</span>與<span style="font-weight: bold;">補數（~）</span>。<br>

      <br>




如果您不會基本的位元運算，以下可以提供一個程式來顯示各個運算的結果：</small>





      <br>




      
      <ul>

        <li>BitwiseOperator.java</li>

      
      </ul>




      
      <pre>public class BitwiseOperator { <br>    public static void main(String[] args) { <br>        System.out.println("AND運算："); <br>        System.out.println("0 AND 0\t\t" + (0 &amp; 0)); <br>        System.out.println("0 AND 1\t\t" + (0 &amp; 1)); <br>        System.out.println("1 AND 0\t\t" + (1 &amp; 0)); <br>        System.out.println("1 AND 1\t\t" + (1 &amp; 1)); <br><br>        System.out.println("\nOR運算："); <br>        System.out.println("0 OR 0\t\t" + (0 | 0)); <br>        System.out.println("0 OR 1\t\t" + (0 | 1)); <br>        System.out.println("1 OR 0\t\t" + (1 | 0)); <br>        System.out.println("1 OR 1\t\t" + (1 | 1)); <br><br>        System.out.println("\nXOR運算："); <br>        System.out.println("0 XOR 0\t\t" + (0 ^ 0)); <br>        System.out.println("0 XOR 1\t\t" + (0 ^ 1)); <br>        System.out.println("1 XOR 0\t\t" + (1 ^ 0)); <br>        System.out.println("1 XOR 1\t\t" + (1 ^ 1)); <br>    } <br>} </pre>




      <br>




      <small><span class="postbody">
執行結果：</span></small><br>




      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">




  <tbody>




    <tr>




      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">AND運算： <br>




0 AND 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 <br>




0 AND 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 <br>




1 AND 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 <br>




1 AND 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 <br>




&nbsp;<br>




OR運算： <br>




0 OR 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 <br>




0 OR 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 <br>




1 OR 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 <br>




1 OR 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 <br>




&nbsp;<br>




XOR運算： <br>




0 XOR 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 <br>




0 XOR 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 <br>




1 XOR 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 <br>




1 XOR 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;</span></small><span style="color: rgb(255, 255, 255);"><br>




      </span></td>




    </tr>




  
  
  
        
        </tbody>
      
      </table>




      <br>

      <small>


Java中的位元運算是逐位元運算的，例如10010001與01000001作AND運算，是一個一個位元對應運算，答案就是00000001；而補數
運算是將所有的位元0變1，1變0，例如00000001經補數運算就會變為11111110，例如下面這個程式所示：<br>

      </small>


      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">byte number = 0; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">




      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">System.out.println((int)(~number));</span><br>




      </small></div>




      <small><br>




這個程式會在主控台顯示-1，因為byte佔記憶體一個位元組，它儲存的0在記憶體中是00000000，經補數運算就變成11111111，這在電腦中
用整數表示則是-1。<br>

      <br>




要注意的是，邏輯運算子與位元運算子也是很常被混淆的，像是<span style="font-weight: bold;">&amp;&amp;與
&amp;</span>，<span style="font-weight: bold;">||與|</span>，初學時可得多注意。<br>

      <br>




位元運算對初學者來說的確較不常用，但如果用的恰當的話，可以增進不少程式效率，例如下面這個程式可以判斷使用者的輸入是否為奇數：</small>





      <br>




      
      <ul>

        <li>BitWiseOperator.java</li>

      
      </ul>




      
      <pre>import java.util.Scanner;<br> <br>public class BitwiseOperator {<br>    public static void main(String[] args) {<br>        Scanner scanner = new Scanner(System.in);<br><br>        System.out.print("請輸入數字: "); <br>        int inputedNumber = scanner.nextInt(); <br>        System.out.println("是否為奇數? " + <br>                  ((inputedNumber&amp;1) != 0 ? '是' : '否')); <br>    }<br>}</pre>




      <br>




      <small><span class="postbody">
執行結果：</span></small><br>




      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">




  <tbody>




    <tr>




      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">請輸入數字: 8<br>




是否為奇數? 否 </span></small><span style="color: rgb(255, 255, 255);"><br>




      </span></td>




    </tr>




  
  
  
        
        </tbody>
      
      </table>




      <br>

      <small>


這個程式得以運算的原理是，奇數的數值若以二進位來表示，其最右邊的位元必為1，而偶數最右邊的位元必為0，所以我們使用1來與輸入的值作AND運算，由
於1除了最右邊的位元為1之外，其它位元都會是0，與輸入數值AND運算的結果，只會留下最右邊位元為0或為的結果，其它部份都被0
AND運算遮掉了，這就是所謂「位元遮罩」，例如：<br style="font-weight: bold;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00000100 -&gt; 4</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00000001 -&gt; 1</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">----------</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00000000 -&gt; 判斷為偶數</span><br style="font-family: Courier New,Courier,monospace;">

      <br style="font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00000011 -&gt; 3</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00000001 -&gt; 1</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">----------</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00000001 -&gt; 判斷為奇數</span><br>

      <br>




XOR的運算較不常見，這邊舉個簡單的XOR字元加密例子，先看看程式： </small>





























      <br>




      
      <ul>

        <li>&nbsp;XorCode.java</li>

      
      </ul>




      
      <pre>public class XorCode { <br>    public static void main(String[] args) { <br>        char ch = 'A'; <br><br>        System.out.println("before encoding：" + ch); <br><br>        ch = (char)(ch^0x7); <br>        System.out.println("after encoding：" + ch); <br><br>        ch = (char)(ch^0x7); <br>        System.out.println("decoding：" + ch); <br>    } <br>}</pre>




      <br>




      <small><span class="postbody">
執行結果：</span></small><br>




      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">




  <tbody>




    <tr>




      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">before encoding：A <br>




after encoding：F <br>




decoding：A</span></small><span style="color: rgb(255, 255, 255);"><br>




      </span></td>




    </tr>




  
  
  
        
        </tbody>
      
      </table>




      <br>

      <small>


0x7是Java中整數的16進位寫法，其實就是10進位的7，將位元與1作XOR的作用其實就是位元反轉，0x7的最右邊三個位元為1，所以其實就是反
轉ch的最後三個位元，如下所示：<br style="font-weight: bold;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">01000001 -&gt; 65 -&gt; 對應ASCII中的'A'</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00000111 -&gt; 0x7</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">----------</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">01000110 -&gt; 70 -&gt; 對應ASCII中的'F'</span><br style="font-family: Courier New,Courier,monospace;">

      <br>




同樣的，這個簡單的XOR字元加密，要解密也只要再進行相同的位元反轉就可以了。<br>

      <br>




要注意的是，雖然在說明時都只取8個位元來說明，但實際的位元在運算時，需依資料型態所佔的記憶體長度而定，例如在使用int型態的0作運算時，要考慮的
是32個位元，而不是只有8個位元，因為int佔有4個位元組。<br>

      <br>




在位元運算上，Java還有<span style="font-weight: bold;">左移（&lt;&lt;）</span>與<span style="font-weight: bold;">右移（&gt;&gt;）</span>兩個運算子，左移運算子會將所有的位元往左移指定的位
數，左邊被擠出去的位元會被丟棄，而右邊會補上0；右移運算則是相反，會將所有的位元往右移指定的位數，右邊被擠出去的位元會被丟棄，至於左邊位元補0或
補1 則視最左邊原來的位元而定，如果原來是0就補0，是1就補1，您還可以使用<span style="font-weight: bold;">&gt;&gt;&gt;</span>運算子，這個運算子在右移後一行在最左邊補上0。<br>

      <br>




可以使用左移運算來作簡單的2次方運算示範，如下所示：</small>























      <br>




      
      <ul>

        <li>&nbsp;ShiftOperator.java</li>

      
      </ul>




      
      <pre>public class ShiftOperator { <br>    public static void main(String[] args) { <br>        int number = 1; <br><br>        System.out.println( "2的0次: " + number); <br><br>        number = number &lt;&lt; 1; <br>        System.out.println("2的1次: " +  number); <br><br>        number = number &lt;&lt; 1; <br>        System.out.println("2的2次: " + number); <br><br>        number = number &lt;&lt; 1; <br>        System.out.println("2的3次：" + number); <br>    } <br>} </pre>




      <br>




      <small><span class="postbody">
執行結果：</span></small><br>




      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">




  <tbody>




    <tr>




      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">2的0次: 1 <br>




2的1次: 2 <br>




2的2次: 4 <br>




2的3次：8&nbsp;</span></small><span style="color: rgb(255, 255, 255);"><br>




      </span></td>




    </tr>




  
  
  
        
        </tbody>
      
      </table>




      <br>

      <small>


實際來左移看看就知道為何可以如此運算了： <br>

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00000001 -&gt; 1</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00000010 -&gt; 2</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00000100 -&gt; 4</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">00001000 -&gt; 8 </span></small>











      <br>



 </td>


      <td style="width: 250px; text-align: center; vertical-align: top;"><comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>&nbsp;
      
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>


      <comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>


      <comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>
      
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>


      <br>
<script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>


      <br>

      
      <center>
      
       <br>


      </center>


 </td>


    </tr>


  
  </tbody>
</table>


<br>

<br>




<br>




<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script>
</body>
<!-- Mirrored from openhome.cc/Gossip/JavaGossip-V1/LogicalBitwiseOperator.htm by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:14:16 GMT -->
</html>