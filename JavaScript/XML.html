<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/JavaScript/XML.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:16:43 GMT -->
<head>

















  
  
  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">







  
  
  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">







  
  
  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>傳送與接收 XML</title></head><body>







<h3><a href="../index.html">From
Gossip@Openhome</a></h3>







<h1><a href="index-2.html">JavaScript Essence: 傳送與接收 XML<br>
</a></h1>

<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">

  <tbody>

    <tr>

      <td style="vertical-align: top; width: 250px; text-align: center;">
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>

      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br><br><center> </center></td>

      <td style="vertical-align: top; width: 690px; text-align: left;">
      <div style="text-align: right;"><a href="http://openhome.cc/eGossip/JavaScript/XML.html">English</a><br>
      </div>
      <small><br>
如果你需要用非同步物件傳送複雜階層的資料，可以使用XML。如果你需要傳送XML，只需將資料組織為XML的字串，<span style="font-family: Courier New,Courier,monospace;">open()時使用'POST'，並設定請求標頭的'Content-Type'為'text/xml'，再使用send()</span>方法將XML字串放在本體中傳送出去。例如：<br>
      </small>
      <div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">function toXML(data) {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">
      <small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; var xml = ['&lt;data&gt;'];</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">
      <small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; for(var name in data) {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">
      <small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xml.push('&lt;' + name + '&gt;');</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">
      <small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xml.push(data[name]);</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">
      <small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xml.push('&lt;/' + name + '&gt;');</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">
      <small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">
      <small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; xml.push('&lt;/data&gt;');</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">
      <small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; return xml.join('');</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">
      <small style="font-family: Courier New,Courier,monospace; font-weight: bold;">}<br>
      <br>
...<br>
var data = { // 假設 data 實際上是由使用者提供<br>
&nbsp;&nbsp;&nbsp; x : 10,<br>
&nbsp;&nbsp;&nbsp; y : 20,<br>
&nbsp;&nbsp;&nbsp; z : 30<br>
};<br>
var request = xhr(); // xhr() 會建立非同步物件<br>
request.onreadystatechange = handleStateChange; // handleStateChange 參考至函式<br>
      </small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">request.</small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">open('POST', url);<br>
      </small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">request.</small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">setRequestHeader('Content-Type', 'text/xml');<br>
request.send(toXML(data));<br>
      </small></div>
      <small><br>
      </small><small>上面這個例子，伺服端會收到的XML字串為（底下是加了一些排版的結果）：<br>
      </small>
      <div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&lt;data&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;x&gt;10&lt;/x&gt;<br>
&nbsp;&nbsp;&nbsp; </span></small><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">&lt;y&gt;20&lt;/y&gt;</small><small style="font-weight: bold; font-family: Courier New,Courier,monospace;"><br>
&nbsp;&nbsp;&nbsp; &lt;z&gt;30&lt;/z&gt;</small><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;"><br>
&lt;/data&gt;</span></small><br>
      </div>
      <small><br>
當然，伺服端必須剖析XML字串，取出所要的資料進行處理，這邊不討論伺服端如何剖析XML字串。<br>
      <br>
      如果伺服端傳回XML字串，則可以使用非同步物件的<span style="font-family: Courier New,Courier,monospace; font-weight: bold;">respnseXML</span>取得XML字串剖析後的DOM物件，之後使用DOM API取出想要的資料進行處理。例如在 </small><small><a href="GET.html">使用 GET 請求</a> 的第一個範例中，使用<span style="font-family: Courier New,Courier,monospace;">innerHTML</span>將傳回的HTML字串設定為&lt;div&gt;的內部HTML，但這樣就是伺服端寫死了客戶端的HTML外觀，你可以改傳回XML，由客戶端取出資料，自行決定外觀處理。<br>
      <br>
例如，若伺服端傳回的XML格式如下（<span style="font-family: Courier New,Courier,monospace;">注意，伺服端必須設定回應標頭的"Content-Type"為"text/xml"，</span>XML<span style="font-family: Courier New,Courier,monospace;">若含中文之類的字元，則必須指定charset</span>編碼）：<br>
      </small>
      <div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&lt;?xml version="1.0" encoding="big5"?&gt;</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">
      <small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&lt;select&gt;</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">
      <small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; &lt;option value="algorithm"&gt;常見演算&lt;/option&gt;</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">
      <small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; &lt;option value="graphic"&gt;電腦圖學&lt;/option&gt;</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">
      <small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; &lt;option value="pattern"&gt;設計模式&lt;/option&gt;</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">
      <small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&lt;/select&gt;</span></small><br>
      </div>
      <small><br>
      </small><small>
      以下是改寫 </small><small> </small><small><a href="GET.html">使用 GET 請求</a> 的第一個範例，處理傳回的XML：<br>
      </small>
      <ul>
        <li><a href="samples/XML-1.html"><small>XML-1.html</small></a></li>
      </ul>
      <pre>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN"&gt;<br>&lt;html&gt;<br>    &lt;head&gt;<br>        &lt;meta content="text/html; charset=Big5" http-equiv="content-type"&gt;<br>        &lt;script type="text/javascript"&gt;<br>            window.onload = function() {<br>                var xhr = window.XMLHttpRequest &amp;&amp; <br>                      (window.location.protocol !== 'file:' <br>                          || !window.ActiveXObject) ?<br>                       function() {<br>                           return new XMLHttpRequest();<br>                       } :<br>                       function() {<br>                          try {<br>                             return new ActiveXObject('Microsoft.XMLHTTP');<br>                          } catch(e) {<br>                             throw new Error('XMLHttpRequest not supported');<br>                          }<br>                       };<br>                <br>                function param(obj) {<br>                    var pairs = [];<br>                    for(var name in obj) {<br>                        var pair = encodeURIComponent(name) + '=' + <br>                                   encodeURIComponent(obj[name]);<br>                        pairs.push(pair.replace('/%20/g', '+'));<br>                    }<br>                    return pairs.join('&amp;');<br>                }<br>                <br>                function ajax(option) {<br>                    option.type = option.type || 'GET';<br>                    option.header = option.header || {<br>                      'Content-Type':'application/x-www-form-urlencoded'};<br>                    option.callback = option.callback || function() {};<br>                    <br>                    if(!option.url) {<br>                        return;<br>                    }<br>                    <br>                    var request = xhr();<br>                    request.onreadystatechange = function() {<br>                        option.callback.call(request, request);<br>                    };<br>                    <br>                    var body = null;<br>                    var url = option.url;<br>                    if(option.data) {<br>                        if(option.type === 'POST') {<br>                            body = param(option.data);<br>                        }<br>                        else {<br>                            url = option.url + '?' + param(option.data) <br>                                     + '&amp;time=' + new Date().getTime();<br>                        }<br>                    }<br>                    <br>                    request.open(option.type, url);<br>                    for(var name in option.header) {<br>                        request.setRequestHeader(<br>                                name, option.header[name]);<br>                    }<br>                    request.send(body);<br>                }<br>                <br>                document.getElementById('category').onchange = function() {<br>                    ajax({<br>                        url     : 'XML-1.php',<br>                        data    : {category : this.value},<br>                        callback: function(request) {<br>                            if(request.readyState === 4) {<br>                                if(request.status === 200) {<br>                                    var select = <br>                                         document.createElement('select');<br><span style="font-weight: bold;">                                    var xml = request.responseXML;<br><span style="font-weight: bold;">                                    // 取得所有 &lt;option&gt;</span><br style="font-weight: bold;"><span style="font-weight: bold;">                                    var options = </span></span><br style="font-weight: bold;"><span style="font-weight: bold;">                                         xml.getElementsByTagName('option');</span><br style="font-weight: bold;"><span style="font-weight: bold;">                                    for(var i = 0; i &lt; options.length; i++) {</span><br style="font-weight: bold;"><span style="font-weight: bold;">                                        // 取得每個 &lt;option&gt; 的 value 屬性</span><br style="font-weight: bold;"><span style="font-weight: bold;">                                        var value = </span><br style="font-weight: bold;"><span style="font-weight: bold;">                                          options[i].getAttribute('value');</span><br style="font-weight: bold;"><br style="font-weight: bold;"><span style="font-weight: bold;">                                        // 取得每個 &lt;option&gt;&lt;/option&gt; 間的文字</span><br style="font-weight: bold;"><span style="font-weight: bold;">                                        // 注意，文字也是節點</span><br style="font-weight: bold;"><span style="font-weight: bold;">                                        var text = </span><br style="font-weight: bold;"><span style="font-weight: bold;">                                          options[i].firstChild.nodeValue;</span><br style="font-weight: bold;">                                       <br>                                        // 不是 IE 的話<br>                                        if(navigator.userAgent<br>                                            .indexOf('MSIE') === -1) {<br>                                            select.add(<br>                                             new Option(text, value), <br>                                              select.options[<br>                                               select.options.length]);<br>                                        }<br>                                        else { // IE 的話<br>                                            select.add(<br>                                              new Option(text, value),<br>                                               select.options.length);<br>                                        }<br><span style="font-weight: bold;">                                    }</span><br>                                    var book = <br>                                         document.getElementById('book');<br>                                    if(book.firstChild) {<br>                                        book.removeChild(book.firstChild);<br>                                    }<br>                                    book.appendChild(select);<br>                                }<br>                            }<br>                        }<br>                    });<br>                };<br>            };<br>        &lt;/script&gt;        <br>    &lt;/head&gt;<br>    &lt;body&gt;<br>        圖書：&lt;br&gt;<br>        &lt;select id="category"&gt;<br>            &lt;option&gt;-- 選擇分類 --&lt;/option&gt;<br>            &lt;option value="theory"&gt;理論基礎&lt;/option&gt;<br>            &lt;option value="language"&gt;程式語言&lt;/option&gt;<br>            &lt;option value="web"&gt;網頁技術&lt;/option&gt;<br>        &lt;/select&gt;&lt;br&gt;&lt;br&gt;<br>        採購：&lt;div id="book"&gt;&lt;/div&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br></pre>
      <br>
      <small>上例的執行結果與</small> <small><a href="GET.html">使用 GET 請求</a> 雖然一樣，但實際上你可以用任意畫面展現傳回的XML資料。<br>
      <br>
上例中並示範了下拉選單的選項在新增時，標準瀏覽器與Internet Explorer不同的處理方式，在這邊無法使用物件偵測來判斷，因為新增下拉的選項時，</small><small>標準瀏覽器與Internet Explorer都是使用<span style="font-family: Courier New,Courier,monospace;">add()</span>方法，差別僅在於第二個參數，<span style="font-weight: bold;">標準瀏覽器必須指定已存在的選項</span>，新增的選項會安插在該選項之前，而<span style="font-weight: bold;">Internet Explorer則必須指定已存在選項的索引位置</span>，</small><small>新增的選項會安插在該選項之前。<br>
      <br>
優先使用物件偵測，只在無法使用物件偵測時，才使用這邊的瀏覽器探測方式。<br>
      </small><small><br>
      </small><br>
</td>

    </tr>

  </tbody>
</table>

<br>
<br>

<br>

<br>







<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script></body>
<!-- Mirrored from openhome.cc/Gossip/JavaScript/XML.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:16:44 GMT -->
</html>