<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/JavaEssence/Synchronized.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:14:05 GMT -->
<head>


  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">

  <link rel="stylesheet" href="css/print.css" type="text/css">

  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>同步？</title></head><body>

<h3><a href="../index.html">From
Gossip@Openhome</a></h3>

<h1><a href="index-2.html">Java Essence: 同步？</a></h1>

<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">

  <tbody>

    <tr>

      <td style="width: 250px; text-align: center; vertical-align: top;">
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>

      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>

      <br>

      <center>
       <br>

      </center>

      </td>

      <td style="vertical-align: top; width: 690px; text-align: left;"><small>執行緒所操作的可執行（Runnable）物件，就相當於JVM中加裝的虛擬CPU所執行的程式碼。如果有兩個執行緒試圖執行的程式碼有所重疊，就要小心所重疊程式碼中共用的資料部份，以免共用存取時，發生資料的競速（Race condition）問題。<br><br>舉個例子來說，如果你開發一個簡單的Stack：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">public class Stack {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; private int[] data;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; private int index;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; public Stack(int capacity) {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = new int[capacity];</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; public void put(int d) {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[index] = d;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index++;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; public int pop() {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index--;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return data[index];</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">}</small><br></div><small><br>index指向陣列中可以儲存資料的索引位置。這個程式使用在單執行緒時沒有問題，但如果使用在多執行緒下，例如某個可執行物件的run()中執行了put()方法：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">public class Some implements Runnable {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; private Stack stack;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; ...</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; public void run() {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; ....</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; stack.put(d);</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; ...</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">}</small><br></div><small><br>假設index原先是2，當執行緒執行put()的第一行時，原本下一步該進行遞增index的動作（也就是變成3），不過此時正巧另一個執行緒執行了pop()：</small><small><br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">public class Other implements Runnable {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; private Stack stack;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; ...</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; public void run() {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; ....</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; int p = stack.pop();</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; ...</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">}</small></div><br><small>當執行緒執行了pop()的第一行遞減index後（變成1了），又回到先前執行緒的執行，此時又遞增了index（變成2了），所以這個時候，原本該遞增的index沒有遞增（原來應該變成3），為錯誤的結果。<br><br>錯
誤發生的原因在於，index為兩個執行緒共用，因而在某些時機點，發生競爭存取的情況，使得原來該在一個方法中完成的單元操作（陣列值指定後，索引也必
須被遞增，這兩個動作不可分割）被另一個執行緒介入。若要解決這個問題，可以將必須由一個執行緒完成的單元操作程式碼鎖定，完成操作後再開放給其它執行緒
存取共用的資料。<br><br>你可以使用synchronized關鍵字，標示執行緒所必須完成的</small><small>單元操作程式碼範圍，例如最基本的，就是標示方法為synchronized：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">public class Stack {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; private int[] data;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; private int index;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; public Stack(int capacity) {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = new int[capacity];</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; public <span style="color: red;">synchronized</span> void put(int d) {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[index] = d;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index++;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; public </small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;"><span style="color: red;">synchronized</span> </small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int pop() {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index--;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return data[index];</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">}</small><br></div><small><br></small><small>每個物件內部都只會有一把鎖定旗標（Lock flag），</small><small>執行緒要進入synchronized所標示的程式碼範圍，都必須取得某物件的</small><small>鎖定旗標</small><small>。以上例而言，在Stack的方法上標示synchronized（此時稱為synchronized method），表示進入synchronized時，必須取得Stack物件的</small><small>鎖定旗標</small><small>（對synchronized metho來說，預設就是取得目前物件的鎖定），若此時另一個執行緒也打算執行</small><small>標示synchronized的方法，由於</small><small>鎖定旗標</small><small>已經被取走了，就只能等待。</small><br><small><img style="width: 444px; height: 290px;" alt="" src="images/Synchronized-1.jpg"><br><br>只有當原先取得</small><small>鎖定旗標</small><small>的執行緒執行完syhchronized區域後將</small><small>鎖定旗標歸還物件後，另一個執行緒才有可能取得</small><small>鎖定旗標而執行所想要進入的synchronized區域。<br><img style="width: 554px; height: 168px;" alt="" src="images/Synchronized-2.jpg"><br><br>所以若是先前的情況，有一個執行緒執行put()方法時，另一個執行緒就不能執行get()方法，所以put()方法內容一定會全執行完，也就不會發生先前競爭存取而引發的錯誤結果。<br><br>如果你確定共用存取的範圍，並不一定要將整個方法都標示為synchronized範圍，而可以如下（這是synchronized statement）：<br></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; public <span style="color: red;"></span>void put(int d) {<br>&nbsp; &nbsp; &nbsp; &nbsp; ...<br>&nbsp; &nbsp; &nbsp; &nbsp; </small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;"><span style="color: red;">synchronized(this) {</span> </small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; data[index] = d;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; index++;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; ...<br style="font-family: Courier New,Courier,monospace; font-weight: bold;"></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; public&nbsp;</small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;"><span style="color: red;"></span></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int pop() {<br></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; ...<br>&nbsp; &nbsp; &nbsp; &nbsp; </small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;"><span style="color: red;">synchronized(this) {</span> </small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; index--;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return data[index];<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; ...<br style="font-family: Courier New,Courier,monospace; font-weight: bold;"></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br><small><br>括號中指定鎖定旗標的物件來源。由於標示</small><small>為synchronized</small><small>範圍</small><small>，一次只允許一個執行緒，所以其它的執行緒等待可能會引發效能問題，減少不必要的</small><small>synchronized</small><small>範圍，可以減少不必要的等待，降低效能負擔。<br><br>使用synchronized statement，可以作到更細部的控制，像是可以提供不同的物件作為鎖定旗標來源：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">public class Material {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; private int data1 = 0;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; private int data2 = 0;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold; color: red;">&nbsp;&nbsp;&nbsp; private Object lock1 = new Object();</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold; color: red;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold; color: red;">&nbsp;&nbsp;&nbsp; private Object lock2 = new Object();</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; public void doSome() {<br>&nbsp; &nbsp; &nbsp; &nbsp; ...<br style="font-family: Courier New,Courier,monospace; font-weight: bold;"></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized(<span style="color: red;">lock1</span>) {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data1++;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<br style="font-family: Courier New,Courier,monospace;"></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; ...</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; public void doOther() {<br></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; ...</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized(<span style="color: red;">lock2</span>) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<br style="font-family: Courier New,Courier,monospace;"></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data2--;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<br style="font-family: Courier New,Courier,monospace;"></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br></small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp; ...</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; }</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">}</small><br></div><small><br>在這邊所要避免的是在doSome()中，同時被兩個以上的執行緒存取synchronized區塊，或是</small><small>doOther
()中，同時被兩個以上的執行緒存取synchronized區塊，但data1與data2並不同時出現在兩個方法中，所以有個執行緒執行doSome
()而另一個執行緒執行doOther()時，並不會引發共用存取問題，此時分別提供不同的物件作為鎖定來源，就不會導致doSome()中
synchronize被一個執行緒存取時，doOther()中synchronized被另一個試圖存取時，所引發的等待延遲。</small><br><small><img style="width: 425px; height: 394px;" alt="" src="images/Synchronized-3.jpg"><br><br></small></td>

    </tr>

  </tbody>
</table>

<br>

<br>

<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script>
</body>
<!-- Mirrored from openhome.cc/Gossip/JavaEssence/Synchronized.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:14:06 GMT -->
</html>