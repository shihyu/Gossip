<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/JavaEssence/String.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:13:25 GMT -->
<head>

  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">

  <link rel="stylesheet" href="css/print.css" type="text/css">

  <meta content="text/html; charset=Big5" http-equiv="content-type">
  <title>那些字串二三事</title></head>
<body>

<h3><a href="../index.html">From
Gossip@Openhome</a></h3>

<h1><a href="index-2.html">Java Essence: 那些字串二三事</a></h1>

<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">

  <tbody>

    <tr>

      <td style="width: 250px; text-align: center; vertical-align: top;">
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>

      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>

      <br>
<script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>

      <br>

      </td>

      <td style="vertical-align: top; width: 690px; text-align: left;"><small>在Java中，要建立字串很方便：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">String str = "Java";</span></small><br><small><span style="font-weight: bold;"></span></small></div><small><span style="font-weight: bold;"><br></span>依Java命名慣例而言，String這個名稱首字大寫，無疑地應該是個類別，這代表了，str是參考至一個String的實例。有些書會說，這個寫法其實等同於以下的寫法，而且這樣有建立物件的明確語義：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">String str = new String("Java");</span></small><br><small><span style="font-weight: bold;"></span></small></div><small><span style="font-weight: bold;"><br></span>這並不是全部的事實。這句話比較像是：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String str1 = "Java";</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String str2 = new String(str1);</small><br></div><small><br>也就是先前的那行程式碼，<span style="font-weight: bold;">其實JVM建立了兩個String實例</span>。這意謂著，直接使用雙引號包括字元來建立字串，以及自行用new關鍵字建立字字串是不同的，這可以由以下的程式碼來驗證：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String str1 = "Java";</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String str2 = new String(str1);</small><br><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">System.out.println(str1 == str2);</small><br></div><small style="font-family: Courier New,Courier,monospace; font-weight: bold;"><br></small><small>==運算子會比較兩個參考名稱是否參考至同一物件，上面的程式片段會印出false，也就是str1與str2是參考至不同物件。</small><small style="font-weight: bold;">直接使用雙引號包括字元來建立字串，JVM會自行在記憶體中使用一個字串池（String pool）來維護，只要雙引號含括的字元內容相同（序列相同，大小寫相同），無論在程式碼中出現幾次，在字串池中都只有一個實例。</small><small style="font-family: Courier New,Courier,monospace; font-weight: bold;"><br><br></small><small style="font-family: Courier New,Courier,monospace;">下面這段程式碼可以驗證：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String str1 = "Java";</small><br style="font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String str2 = "Java";</small><br style="font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">System.out.println(str1 == str2);</small><br></div><small><br>這個程式碼片段會印出true，因為雙引號含括的內容都是Java這個字元序列，雖然程式碼中出現了兩次"Java"，但在字串池中卻只有一個實例，只不過依程式碼所定義的，被str1與str2所參考著。<br><br>一般書籍都會說，要比較字串是否相等要使用equals()方法而不是==，這個意思是指比較字串所含字元序列的相等性，而非參考名稱所參考的記憶體位置相等性。下面這個程式碼會顯示true，因為str1與str2所參考之物件，其所含字元序列都相等：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String str1 = "Java";</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String str2 = new String(str1);</small><br><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">System.out.println(str1.equals(str2));</small><br></div><small><br>每個字串都是不可變動的，這表示你一旦建立字串，就不可以修改它的字元內容。字串的字元內容，是維護在String中的字元陣列中：<br style="font-weight: bold;"></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">public final class String</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; /** The value is used for character storage. */</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; private final char value[];</span></small><br></div><small><br>下面這段程式碼，只不過是將字串內含字元陣列給另一個字串在內部複製或參考：<br><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public String(String original) {</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; int size = original.count;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; char[] originalValue = original.value;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; char[] v;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; if (originalValue.length &gt; size) {</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; v = Arrays.copyOfRange(originalValue, off, off+size);</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</span><span style="font-weight: bold; font-family: Courier New,Courier,monospace;"></span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v = originalValue;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; this.offset = 0;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; this.count = size;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; this.value = v;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; }</span><br><br>其它的字串建構式也是類似的。<span style="font-weight: bold;">String上還有個intern()方法，可以讓你將字串放入字串池，或者是從字串池中取得JVM所維護的字串。如果你呼叫它，則會使用equals()方法，比較字串池中是否有字元序列相同的字串，如果有則傳回，如果無則將該字串置入字串池。</span><br><br>所以下面這個程式碼執行結果會是true：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String str1 = "Java";</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String str2 = new String(str1);</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">System.out.println(str1 == str2.intern());</small><br></div><small><br>在Java中，可以使用+串接字串，例如：<br></small><div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">String str1 = "Java";</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">String str2 = "Cool";</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">String str3 = str1 + str2;</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">System.out.println(str3);</span></small><br></div><small><br>最後顯示的是JavaCool。一應該都會告訴你，用+串接字串很方便，但要小心+會產生新的字串。這也不是全部的事實，因為它產生的更多，如果使用的是JDK5以上，可以實際反組譯看看：<br></small><div style="margin-left: 40px;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">String s = "Java";</small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">String s1 = "Cool";</small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">String s2 = (new StringBuilder()).append(s).append(s1).toString();</small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">System.out.println(s2);</small><br></div><small><br><span style="font-weight: bold;">如
果是JDK1.4以下，則會在JVM內部產生StringBuffer完成類似的字串附加動作。StringBuilder或StringBuffer，
內部也是使用自動增加的字元陣列來維護，若長度不夠，則會產生新的更長的字元陣列，然後作字元陣列複製的動作。所以若是有頻繁串接字串的動作，例如在迴圈
中串接SQL之類的，會有效能上的隱憂，應當避免。</span><br><br>不過下面這個稍微有點不同：<br></small><div style="margin-left: 40px;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">String str = "Java" + "Cool";</small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">System.out.println(str);</small><br></div><small><br>執行結果一樣顯示JavaCool，不過反組譯它，你會發現編譯器很聰明：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">String s = "JavaCool";</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">System.out.println(s);</span></small><br></div><small><br>既然兩個都是雙引號括著，又直接使用+串接，那你要的不就是"JavaCool"？<br><br>附帶一提的是，<span style="font-weight: bold;">字串與物件之間也是可以使用+串接的！</span>例如：<br></small><div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">Map map = new HashMap();</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">map.put("key", "value");</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">System.out.println("Map: " + map);</span></small><br></div><small><br>這沒什麼！如果字串與物件使用+串接，其實最後會呼叫物件的toString()取得物件的字串描述，也就是說類似於：<br></small><div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">Map map = new HashMap();</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">map.put("key", "value");</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">System.out.println("Map: " + map.toString());</span></small><br></div><small><br>這也不完全是事實，上面只是比喻！編譯器（或JVM）作的更多：<br></small><div style="margin-left: 40px;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">HashMap hashmap = new HashMap();</small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">hashmap.put("key", "value");</small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">System.out.println(<br>&nbsp; &nbsp; &nbsp; &nbsp; (new StringBuilder()).append("Map: ").append(hashmap).toString());</small><br></div><small><br>至於StringBuilder的append()作了什麼，留待你自行去探索一下它的原始碼吧！<br><br>延伸閱讀 <a href="http://www.javablogging.com/string-and-memory-leaks/">String and memory leaks</a>。<br><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span></small></td>

    </tr>

  </tbody>
</table>

<br>

<br>

<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script>
</body>
<!-- Mirrored from openhome.cc/Gossip/JavaEssence/String.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:13:25 GMT -->
</html>