<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/JavaEssence/ArrayObject.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:13:30 GMT -->
<head>


  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">

  <link rel="stylesheet" href="css/print.css" type="text/css">

  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>陣列是物件</title></head><body>

<h3><a href="../index.html">From
Gossip@Openhome</a></h3>

<h1><a href="index-2.html">Java Essence: 陣列是物件</a></h1>

<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">

  <tbody>

    <tr>

      <td style="width: 250px; text-align: center; vertical-align: top;"><script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>

      <br>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>

      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>

      <br>

      <center>
       <br>

      </center>

      </td>

      <td style="vertical-align: top; width: 690px; text-align: left;"><small><span style="font-weight: bold;">在Java中陣列是物件，這點無庸置疑，它擁有物件的所有特性。</span>因為陣列也是一種Object，下面這段程式碼會顯示true：<span style="font-weight: bold;"><br></span></small><div style="margin-left: 40px;"><small><span style="font-family: Courier New,Courier,monospace; font-weight: bold;">int[] arr = new int[10];</span></small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small><span style="font-family: Courier New,Courier,monospace; font-weight: bold;">System.out.println(arr instanceof Object);</span></small><br></div><small><br>陣列有個簡單的初始方式：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int[] arr = {1, 2, 3, 4};</small><br></div><small><br>這樣的語法是模彷C/C++，但似乎讓人容易忽略了陣列是物件的事實，這個初始式等同於：<br></small><div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int[] arr = new int[] {1, 2, 3, 4};</span></small><br></div><small><br>由於陣列是物件，所以也有 </small><a href="EqualOperator.html"><small>我們沒什麼不同</small></a> <small>與 <a href="CallByValue.html">Call by value？</a> 中所說明的行為，所以，下面這個程式片段不是陣列複製：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int[] arr1 = {1, 2, 3, 4};</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int[] arr2 = arr1;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">arr2[0] = 10;</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">System.out.println(arr1[0]);</small><br></div><small><br>在arr1指定給arr2時，arr1所參考的陣列物件，與arr2所參考的陣列物件是相同的，所以最後顯示的會是10。要進行陣列複製，以下是個簡單的範例：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int[] arr1 = {1, 2, 3, 4};</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int[] arr2 = new int[arr1.length];</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">for(int i = 0; i &lt; arr1.length; i++) {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; arr2[i] = arr1[i];</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">}</small><br></div><small><br>不過用迴圈走訪的方式來複製陣列，並不是有效率的作法，<span style="font-weight: bold;">在System類別上有個靜態方法arraycopy()，其以原生方式進行陣列複製，比迴圈走訪的方式來的有效率</span>，特別是在陣列元素多時更為明顯：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">int[] arr1 = {1, 2, 3, 4};</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">int[] arr2 = new int[arr1.length];</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">System.arraycopy(arr1, 0, arr2, 0, arr1.length);</span></small><br style="font-weight: bold;"></div><small><br>如果建立陣列時不設定其元素值，例如：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">int[] arr1 = new int[10];</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-weight: bold; font-family: Courier New,Courier,monospace;">double[] arr2 = new double[10];</small><br style="font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">boolea[] arr3 = new boolean[10];</span></small><br style="font-weight: bold;"></div><small><br>則整數預設元素值為0，浮點數預設為0.0，而布林值預設為false。但是：<br></small><div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">String[] str = new String[3];</span></small><br></div><small><br>這個並非產生三個字串物件，而是產生一個陣列物件，而當中的每個元素都是一個參考名稱，而且<span style="font-weight: bold;">都指向null</span>。當參考目前不打算指向任何物件時，可以設定其指向null。</small><small style="font-weight: bold;">null不是物件，在Java中是個特殊型態，</small><small><span style="font-weight: bold;">在內部中可以實作為0，但null不是基本型態，可以轉型被設定給任何參考名稱，null只等於null本身。</span>上面的程式碼片段可以用下圖來表示：<br><img style="width: 333px; height: 161px;" alt="" src="images/ArrayObject-1.jpg"><br><br>每個索引值，都是一個參考名稱。你可以讓索引值指向某個物件，例如：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">str[0] = new String("Justin");</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">str[1] = new String("momor");</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">str[2] = new String("hamimi");</small><br></div><small><br>現在有三個字串物件與與個陣列物件了，結果可用下圖來表示：<br><img style="width: 388px; height: 213px;" alt="" src="images/ArrayObject-2.jpg"><br>也可以在建構陣列時，使用初始式的方式來指定初值，例如：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">String[] str = {new String("Justin"), new String("momor"), new String("hamimi")};</small><br></div><small><br>不過要小心字串的特性：<br></small><div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">String[] str = {"Justin", "Justin", "Justin"};</span></small><br></div><small><br>這產生一個陣列物件，一個字串物件，因為字串使用""括住，所以在字串池中只有一個實例：<br><img style="width: 373px; height: 209px;" alt="" src="images/ArrayObject-3.jpg"><br><br>多維陣列基本上是以一維陣列物件來模擬，所以：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int[][] arr = new int[3][5];</small><br></div><small><br>這可以這樣表示：<br><img style="width: 391px; height: 388px;" alt="" src="images/ArrayObject-4.jpg"><br><br>其
中arr[0]、arr[1]、arr[2]都是可以參考至一維陣列物件的名稱，而由於是整數基本型態，一維陣列的元素初始值都是0。陣列上有個
length成員，如果你使用arr.length，表示取得arr所參考陣列物件的長度，也就是3，如果使用arr[0].length，表示取得
arr[0]所參考物件的長度，也就是5。<br><br>如果是類別所宣告的型態，則情況略有不同：<br></small><div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">String[][] arr = new String[3][5];</span></small><br></div><small><br>這實際上不是產生15個物件，而是產生四個物件，因為：<br><img style="width: 509px; height: 395px;" alt="" src="images/ArrayObject-5.jpg"><br><br>另外要注意，<span style="font-weight: bold;">System的arraycopy()方法，只作淺層複製（shallow copy）</span>，也就是若是以類別所宣告的陣列，它實際上不複製索引所參考之物件，例如：<br style="font-weight: bold;"></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">Customer[] arr1 = {</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Customer() {</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{number = 10;}</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">Customer[] arr2 = new Customer[arr1.length];</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">System.arraycopy(arr1, 0, arr2, 0, arr1.length);</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">arr2[0].number = 100;</span></small><br style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;">System.out.println(arr1[0].number);</span></small><br></div><small><br>即使是物件本身上的clone()或是Java SE 6的Arrays所新增的copyOf()方法（Arrays類別提供許多處理陣列的方法，值得看一看），所作的也都是淺層複製。<br><br>既然陣列在Java中是個物件，那麼是否有個類別提供產生物件？答案是肯定的，不過，這個類別是由JVM所產生的，你可以使用這個程式片段作簡單的驗證：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int[] arr = new int[0];</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">Class c = arr.getClass();</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">System.out.println(c.getName());</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">System.out.println(c.getClassLoader());<br>c.newInstance();<br></small></div><small><br>因
為是整數陣列，所顯示的類別名稱I]，因為是JVM自動產生的，沒有任何.class需要載入，所以沒有ClassLoader，所以第二行顯示
null，陣列類別是由JVM產生並根據其實例化，你不能自己實例化，所以最後一行會發生InstantiationException例外。<br><br>下面這個程式會顯示陣列的類別資訊為public abstract final class [I：<br></small><div style="margin-left: 40px;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int[] arr = new int[0];</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">Class c = arr.getClass();</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">Package p = c.getPackage();</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">if(p != null) {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; System.out.printf("package %s;%n", p.getName());</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">}</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">int m = c.getModifiers();</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">System.out.print(Modifier.toString(m) + " ");</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">if(Modifier.isInterface(m)) {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; System.out.print("interface ");</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">}</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">else {</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; System.out.print("class ");</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">}</small><br style="font-family: Courier New,Courier,monospace; font-weight: bold;"><small style="font-family: Courier New,Courier,monospace; font-weight: bold;">System.out.println(c.getName());</small><br></div><small><br></small><small><span style="font-weight: bold;"><br><br></span></small></td>

    </tr>

  </tbody>
</table>

<br>

<br>

<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script>
</body>
<!-- Mirrored from openhome.cc/Gossip/JavaEssence/ArrayObject.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:13:34 GMT -->
</html>